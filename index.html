<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é¹¿é¹¿è¿·å®® GOï¼</title>

  <style>
    :root{
      --bg1:#1a1633;
      --bg2:#0b0b14;
      --panel:#151634cc;

      --text:#fff7ee;
      --muted:#e9d7c9;

      /* giraffe palette */
      --giraffe-base:#f6d8aa;
      --spotA:#7a4a2a;
      --spotB:#a56a3f;
      --deep:#2a160d;

      /* fluffy wall palette */
      --plush-base:#d9a46a;
      --plush-edge:#6b3d22;
      --plush-hi:#ffe6c7;
      --plush-mid:#e9bf8a;
      --plush-shadow:#4a2816;

      --dotLeaf:#78ffb0;
      --dotLeaf2:#2fb86c;

      --powerGold:#ffd26a;
      --powerGold2:#ff9b3d;

      --ok:#7dffbf;
      --radius:18px;

      --safeB: env(safe-area-inset-bottom);
      --safeT: env(safe-area-inset-top);

      --hudH: 54px;
      --barH: 54px;
      --dpadH: 150px;
      --gap: 10px;
    }

    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(900px 600px at 50% 15%, rgba(255,212,150,.18), transparent 60%),
        radial-gradient(700px 500px at 15% 85%, rgba(255,220,170,.10), transparent 55%),
        radial-gradient(700px 500px at 85% 85%, rgba(255,220,170,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC","PingFang TC","Microsoft JhengHei", Arial, sans-serif;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{
      height:100%;
      display:grid;
      grid-template-rows: auto 1fr auto auto;
      gap: var(--gap);
      padding: 10px 10px calc(10px + var(--safeB));
      box-sizing:border-box;
    }

    .card{
      background:var(--panel);
      border:1px solid #ffffff22;
      border-radius: var(--radius);
      box-shadow: 0 12px 40px #00000055;
      backdrop-filter: blur(8px);
    }

    .hud{
      height: calc(var(--hudH) + var(--safeT));
      padding: calc(8px + var(--safeT)) 10px 8px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      overflow:hidden;
    }
    .hud .left{
      display:flex; gap:8px; align-items:center;
      min-width:0; flex:1; overflow:hidden;
    }
    .hud .pill{
      border:1px solid #ffffff22;
      background:#00000022;
      padding:6px 8px;
      border-radius:999px;
      font-size:12px;
      white-space:nowrap;
      flex:0 0 auto;
      color: var(--text);
    }
    .hud .pill b{color:#fff}
    .hud .name{ max-width: 34vw; overflow:hidden; text-overflow:ellipsis; }

    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #ffffff22; font-size:12px; color:#ffe9cf;
      background:#00000022;
      white-space:nowrap;
    }

    .stage{
      position:relative;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:visible;
    }

    canvas{
      width: 100%;
      max-width: 980px;
      height:auto;
      max-height: calc(100vh - (var(--hudH) + var(--barH) + var(--dpadH) + (var(--gap) * 6) + var(--safeT) + var(--safeB)));
      border-radius: var(--radius);
      border:1px solid #ffffff22;
      background:#000;
      box-shadow: 0 18px 60px #00000088;
      image-rendering: pixelated;
      touch-action:none;
      display:block;
    }

    .bar{
      height: var(--barH);
      padding: 8px 10px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .bar .btns{
      display:flex; gap:8px; align-items:center;
      width:100%;
      justify-content:space-between;
    }
    button{
      border:1px solid #ffffff22;
      background: linear-gradient(180deg, #2a1c3e, #14163a);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
    }
    button:active{transform:translateY(1px)}
    button[disabled]{opacity:.55; cursor:not-allowed}

    .dpad{
      padding: 8px 10px;
      box-sizing:border-box;
      height: var(--dpadH);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .dpadWrap{
      width: min(720px, 100%);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 60px 60px;
      gap: 12px;
    }
    .padBtn{
      border-radius: 18px;
      border:1px solid #ffffff22;
      background:
        radial-gradient(120px 60px at 30% 30%, rgba(255,220,170,.25), transparent 60%),
        #ffffff14;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action: manipulation;
      font-weight:900;
      font-size:18px;
    }
    .padBtn:active{filter:brightness(1.12); transform:translateY(1px)}
    .padIcon{
      width:26px; height:26px;
      display:flex; align-items:center; justify-content:center;
      border-radius:6px;
      background: linear-gradient(180deg, #ffcf7a, #b76b34);
      border:2px solid #00000055;
      color:#2a160d;
      font-size:16px;
      line-height:1;
    }
    .padLeft { grid-column:1; grid-row:1; }
    .padUp   { grid-column:2; grid-row:1; }
    .padRight{ grid-column:3; grid-row:1; }
    .padDown { grid-column:2; grid-row:2; }

    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background:#00000066;
      padding:16px;
    }
    .modal{
      width:min(92vw, 520px);
      border-radius: 22px;
      border:1px solid #ffffff22;
      background: linear-gradient(180deg,#1d1b3f,#0b0c18);
      box-shadow: 0 20px 80px #000000aa;
      padding:16px;
      pointer-events:auto;
    }
    .modal h2{margin:2px 0 10px; font-size:18px}
    .modal p{margin:6px 0; color:var(--muted); font-size:13px; line-height:1.45}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px}
    input{
      flex:1;
      min-width: 160px;
      border-radius: 14px;
      border:1px solid #ffffff22;
      background:#00000033;
      color:var(--text);
      padding:12px 12px;
      font-size:15px;
      outline:none;
    }
    .hint{font-size:12px; color:#d9c6b5; opacity:.95}
    .loadBarOuter{
      height:10px;
      background:#00000033;
      border:1px solid #ffffff22;
      border-radius:999px;
      overflow:hidden;
    }
    .loadBarInner{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, #ffe082, #7dffbf);
    }

    .lbBox{
      margin-top:10px;
      border:1px solid #ffffff14;
      border-radius: 14px;
      overflow:hidden;
      max-height: 220px;
      overflow:auto;
      background:#00000022;
    }
    table{width:100%; border-collapse:collapse; font-size:13px}
    th,td{padding:8px 10px; border-bottom:1px solid #ffffff14}
    th{color:#ffe9cf; text-align:left; background:#00000022}
    td{color:#fff7ee}

    /* âœ… ç©æ³•è¦–çª—ï¼šè£œå¼·åŒ–èªªæ˜ï¼ˆæ›´å®Œæ•´ä½†ä¸å†—é•·ï¼‰ */
    .helpModal{
      position:absolute;
      inset:auto 10px calc(var(--dpadH) + var(--barH) + 30px + var(--safeB)) 10px;
      max-width: 540px;
      margin: 0 auto;
      display:none;
      padding:12px 12px;
      border:1px solid #ffffff22;
      background:
        radial-gradient(240px 160px at 10% 10%, rgba(255,220,170,.22), transparent 60%),
        linear-gradient(180deg,#1d1b3f,#0b0c18);
    }
    .helpModal h3{margin:0 0 8px; font-size:16px}
    .helpModal .line{margin:6px 0; font-size:13px; color:var(--muted); line-height:1.4}
    .helpModal .line b{color:#fff}
    .helpModal .chip{
      display:inline-block;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #ffffff22;
      background:#00000022;
      margin-right:6px;
      color:#ffe9cf;
      white-space:nowrap;
    }

    @media (max-width: 420px){
      :root{ --dpadH: 140px; }
      button{ padding:10px 10px; font-size:12px; }
      .hud .pill{ font-size:11px; padding:6px 7px; }
      .padBtn{ border-radius:16px; }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="card hud">
      <div class="left">
        <div class="pill name">ğŸ¦Œ <b id="nick">-</b></div>
        <div class="pill">â­ <b id="score">0</b></div>
        <div class="pill">â¤ï¸ <b id="lives">3</b></div>
        <div class="pill">ğŸƒ <b id="remain">0</b></div>
        <div class="pill">âš¡ <b id="state" style="color:var(--ok)">ä¸€èˆ¬</b></div>
      </div>
      <div class="right">
        <span class="tag">é•·é ¸é¹¿èŠ±è‰²ä¸»é¡Œ</span>
      </div>
    </div>

    <div class="stage">
      <canvas id="game" width="840" height="510"></canvas>

      <div class="card helpModal" id="helpCard">
        <h3>ç©æ³•</h3>

        <div class="line"><span class="chip">æ“ä½œ</span>é»æ–¹å‘éµç§»å‹•ï¼ˆæ¡Œæ©Ÿæ–¹å‘éµ/WASDï¼‰</div>

        <div class="line"><span class="chip">åƒå«©è‘‰é»</span>åœ°åœ–ä¸Šçš„ <b>å°å«©è‘‰</b>ï¼š<b>+1 åˆ†</b></div>

        <div class="line"><span class="chip">èƒ½é‡æœ</span>åœ°åœ–ä¸Šçš„ <b>é‡‘è‰²èƒ½é‡æœ</b>ï¼š<b>+5 åˆ†</b></div>

        <div class="line">
          <span class="chip">å¼·åŒ–</span>
          åƒåˆ°èƒ½é‡æœå¾Œé€²å…¥ <b>å¼·åŒ–æ¨¡å¼ï¼ˆ7 ç§’ï¼‰</b>ï¼š<br/>
          ãƒ»ä½ èº«ä¸Šæœƒå‡ºç¾ <b>é‡‘è‰²å…‰æšˆ</b>ï¼ˆHUD ç‹€æ…‹é¡¯ç¤ºã€Œå¼·åŒ–ã€ï¼‰<br/>
          ãƒ»æ•µäººæœƒè®Šæˆ <b>è—è‰²å¼±åŒ–å…‰åœˆ</b>ï¼ˆå¯ç›®è¦–ï¼‰<br/>
          ãƒ»ç¢°åˆ°å¼±åŒ–æ•µäººå¯ <b>ååƒ +10 åˆ†</b>
        </div>

        <div class="line"><span class="chip">å¤±æ•—</span>éå¼·åŒ–æ™‚ç¢°åˆ°æ•µäººï¼š<b>-1 ç”Ÿå‘½</b></div>
      </div>

      <div class="overlay" id="overlay">
        <div class="modal" id="modal">
          <h2 id="modalTitle">é¹¿é¹¿è¿·å®® GOï¼</h2>
          <p id="modalText">è¼¸å…¥æš±ç¨±å¾Œé–‹å§‹ï¼ˆæ’è¡Œæ¦œä¿ç•™ 7 å¤©ï¼Œåªé¡¯ç¤ºå‰ 6 åï¼‰ã€‚</p>

          <div class="row">
            <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆæœ€å¤š12å­—ï¼‰" />
            <button id="btnStart">é–‹å§‹éŠæˆ²</button>
          </div>

          <div style="margin-top:10px">
            <div class="hint" id="loadText">è¼‰å…¥åœ–æª”ä¸­â€¦</div>
            <div class="loadBarOuter">
              <div id="loadBar" class="loadBarInner"></div>
            </div>
          </div>

          <p class="hint" style="margin-top:10px">
            ğŸ“Œ LINE/iOS éœ€é¦–æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚<br/>
            æ“ä½œï¼šæ‰‹æ©Ÿé»æ–¹å‘éµï¼›æ¡Œæ©Ÿå¯ç”¨æ–¹å‘éµ/WASDã€‚
          </p>

          <div style="margin-top:12px; display:flex; justify-content:space-between; align-items:center; gap:10px">
            <span class="tag">ğŸ† å‰ 6 åï¼ˆ7 å¤©å…§ï¼‰</span>
            <span class="hint" id="lbHint"></span>
          </div>
          <div class="lbBox">
            <table>
              <thead><tr><th>#</th><th>æš±ç¨±</th><th>åˆ†æ•¸</th><th>æ—¥æœŸ</th></tr></thead>
              <tbody id="lbBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="card bar">
      <div class="btns">
        <button id="btnRestart">ğŸ”„ é‡æ–°é–‹å§‹</button>
        <button id="btnSound">ğŸ”Š è²éŸ³ï¼šé–‹</button>
        <button id="btnHelp">â“ ç©æ³•</button>
      </div>
    </div>

    <div class="card dpad">
      <div class="dpadWrap">
        <div class="padBtn padLeft"  id="padLeft"><div class="padIcon">â†</div></div>
        <div class="padBtn padUp"    id="padUp"><div class="padIcon">â†‘</div></div>
        <div class="padBtn padRight" id="padRight"><div class="padIcon">â†’</div></div>
        <div class="padBtn padDown"  id="padDown"><div class="padIcon">â†“</div></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const IMG = {
    player: "https://raw.githubusercontent.com/z883662/Aruru/main/lulu1.png",
    dad:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu2.png",
    mom:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu3.png",
    water:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu4.png",
    angry:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu5.png",
  };

  const MAP = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.#####.##.#####.######",
    "#....#.#####.##.#####.#....#",
    "######.##..####..##.########",
    "#..........##..G..##.......#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "#......##....P.....##......#",
    "############################",
  ];

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const elNick   = document.getElementById("nick");
  const elScore  = document.getElementById("score");
  const elLives  = document.getElementById("lives");
  const elRemain = document.getElementById("remain");
  const elState  = document.getElementById("state");

  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalText  = document.getElementById("modalText");
  const nameInput  = document.getElementById("nameInput");
  const btnStart   = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");
  const btnSound   = document.getElementById("btnSound");
  const btnHelp    = document.getElementById("btnHelp");
  const helpCard   = document.getElementById("helpCard");

  const lbBody = document.getElementById("lbBody");
  const lbHint = document.getElementById("lbHint");

  const loadText = document.getElementById("loadText");
  const loadBar  = document.getElementById("loadBar");

  const padLeft  = document.getElementById("padLeft");
  const padUp    = document.getElementById("padUp");
  const padRight = document.getElementById("padRight");
  const padDown  = document.getElementById("padDown");

  // ===== Audio =====
  let audioEnabled = true;
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudioUnlocked(){
    if (!audioEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioUnlocked = true;
  }
  function beep(freq=520, dur=0.05, type="sine", gain=0.03){
    if (!audioEnabled || !audioUnlocked) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }
  window.addEventListener("pointerdown", ensureAudioUnlocked, {passive:true});

  // ===== Leaderboard =====
  const LB_KEY = "lulu_pacman_lb_final_plush_v1";
  const KEEP_MS = 7 * 24 * 60 * 60 * 1000;

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      const now = Date.now();
      return arr.filter(x => x && typeof x.score==="number" && typeof x.name==="string" && typeof x.ts==="number" && (now - x.ts) <= KEEP_MS);
    }catch(e){ return []; }
  }
  function saveLB(arr){
    try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch(e){}
  }
  function updateLB(name, score){
    const now = Date.now();
    let lb = loadLB();
    lb.push({name, score, ts: now});
    lb.sort((a,b)=> b.score - a.score || b.ts - a.ts);
    lb = lb.slice(0,6);
    saveLB(lb);
    renderLB();
  }
  function fmtDate(ts){
    const d = new Date(ts);
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  function escapeHtml(s){
    return (s+"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function renderLB(){
    const lb = loadLB();
    lbBody.innerHTML = lb.map((r,i)=>(
      `<tr><td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${r.score}</td><td>${fmtDate(r.ts)}</td></tr>`
    )).join("") || `<tr><td colspan="4" style="color:#e9d7c9">ç›®å‰æ²’æœ‰ç´€éŒ„</td></tr>`;
    lbHint.textContent = lb.length ? "ï¼ˆè‡ªå‹•æ¸…é™¤è¶…é 7 å¤©ï¼‰" : "ï¼ˆä½ æœƒæ˜¯ç¬¬ä¸€åï¼‰";
  }

  // ===== Preload images =====
  const images = {};
  function loadImageWithTimeout(src, timeoutMs = 15000){
    return new Promise((resolve, reject) => {
      const im = new Image();
      const timer = setTimeout(() => { cleanup(); reject(new Error("timeout")); }, timeoutMs);
      function cleanup(){ clearTimeout(timer); im.onload=null; im.onerror=null; }
      im.onload = () => { cleanup(); resolve(im); };
      im.onerror = () => { cleanup(); reject(new Error("error")); };
      const bust = (src.includes("?") ? "&" : "?") + "v=" + Date.now();
      im.src = src + bust;
    });
  }

  async function preloadAllImages(){
    const entries = [
      ["player", IMG.player],
      ["dad",    IMG.dad],
      ["mom",    IMG.mom],
      ["water",  IMG.water],
      ["angry",  IMG.angry],
    ];

    let done = 0;
    const total = entries.length;
    const failed = [];

    btnStart.disabled = true;
    loadText.textContent = `è¼‰å…¥åœ–æª”ä¸­â€¦ 0 / ${total}`;
    loadBar.style.width = `0%`;

    for (const [k, src] of entries){
      try{ images[k] = await loadImageWithTimeout(src); }
      catch(e){ images[k] = null; failed.push(k); }
      done++;
      loadText.textContent = `è¼‰å…¥åœ–æª”ä¸­â€¦ ${done} / ${total}`;
      loadBar.style.width = `${Math.round(done/total*100)}%`;
    }

    loadText.textContent = failed.length
      ? "âš ï¸ åœ–æª”è¼‰å…¥å¤±æ•—ï¼š" + failed.join("ã€") + "ï¼ˆå°‡ç”¨å‚™æ´åœ–å½¢ï¼‰"
      : "âœ… åœ–æª”è¼‰å…¥å®Œæˆï¼å¯ä»¥é–‹å§‹äº†";
    btnStart.disabled = false;
  }

  // ===== Game params =====
  const TILE = 30;
  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  canvas.width  = COLS * TILE;
  canvas.height = ROWS * TILE;

  const SPEED_PLAYER = 5.2;
  const SPEED_GHOST  = 4.9;
  const SPEED_FRIGHT = 3.3;

  const POWER_TIME = 7.0;
  const RESPAWN_TIME = 1.6;

  // ===== Map data =====
  const grid = [];
  const leaves = new Set(); // âœ… å«©è‘‰é»ï¼ˆçµ±ä¸€ï¼šåŸæœ¬ç™½é»ï¼‰
  const powers = new Set(); // èƒ½é‡æœ
  let playerStart = {r:0,c:0};
  let ghostHome = {r:0,c:0};

  function key(r,c){ return r + "," + c; }

  function parseMap(){
    grid.length = 0;
    leaves.clear(); powers.clear();

    for (let r=0; r<ROWS; r++){
      const row = [];
      const line = MAP[r];
      for (let c=0; c<COLS; c++){
        const ch = line[c] || "#";
        const isWall = (ch === "#");
        row.push(isWall ? 1 : 0);
        if (ch === ".") leaves.add(key(r,c));
        if (ch === "o") powers.add(key(r,c));
        if (ch === "P") playerStart = {r,c};
        if (ch === "G") ghostHome = {r,c};
      }
      grid.push(row);
    }
  }

  function isWall(r,c){
    if (c < 0 || c >= COLS) return false;
    if (r < 0 || r >= ROWS) return true;
    return grid[r][c] === 1;
  }

  // ===== Directions =====
  const DIRS = {
    up:    {dr:-1, dc: 0},
    down:  {dr: 1, dc: 0},
    left:  {dr: 0, dc:-1},
    right: {dr: 0, dc: 1},
    none:  {dr: 0, dc: 0},
  };
  function opposite(d){
    if (d===DIRS.up) return DIRS.down;
    if (d===DIRS.down) return DIRS.up;
    if (d===DIRS.left) return DIRS.right;
    if (d===DIRS.right) return DIRS.left;
    return DIRS.none;
  }
  function canMove(r,c,dir){
    const nr = r + dir.dr;
    let nc = c + dir.dc;
    if (nc < 0) nc = COLS-1;
    if (nc >= COLS) nc = 0;
    if (nr < 0 || nr >= ROWS) return false;
    return !isWall(nr,nc);
  }
  function atCenter(x){ return Math.abs(x - Math.round(x)) < 0.05; }

  // ===== State =====
  let nickName = "-";
  let score = 0;
  let lives = 3;
  let powerLeft = 0;
  let running = false;
  let lastTime = 0;

  const player = { r:0, c:0, dir:DIRS.left, nextDir:DIRS.left };

  const ghosts = [
    { name:"é¹¿çˆ¸",     imgKey:"dad",   r:0, c:0, dir:DIRS.left,  base:"chaser", respawn:0, patrolIndex:0 },
    { name:"èŠ±åª½",     imgKey:"mom",   r:0, c:0, dir:DIRS.right, base:"ambush", respawn:0, patrolIndex:1 },
    { name:"é˜¿æ°´",     imgKey:"water", r:0, c:0, dir:DIRS.up,    base:"patrol", respawn:0, patrolIndex:2 },
    { name:"ç”Ÿæ°£é¹¿é¹¿", imgKey:"angry", r:0, c:0, dir:DIRS.down,  base:"random", respawn:0, patrolIndex:3 },
  ];
  const patrolCorners = [
    {r:1, c:1},
    {r:1, c:COLS-2},
    {r:ROWS-2, c:1},
    {r:ROWS-2, c:COLS-2},
  ];

  function syncHUD(){
    elNick.textContent = nickName;
    elScore.textContent = score;
    elLives.textContent = lives;
    elRemain.textContent = leaves.size + powers.size;

    if (powerLeft > 0){
      elState.textContent = "å¼·åŒ–";
      elState.style.color = "var(--powerGold)";
    } else {
      elState.textContent = "ä¸€èˆ¬";
      elState.style.color = "var(--ok)";
    }
  }

  function findOpenNear(r,c){
    const offsets = [[0,0],[0,-1],[0,1],[-1,0],[1,0],[0,-2],[0,2],[-2,0],[2,0]];
    for (const [dr,dc] of offsets){
      const rr = r+dr, cc = c+dc;
      if (rr>=0 && rr<ROWS && cc>=0 && cc<COLS && !isWall(rr,cc)) return {r:rr,c:cc};
    }
    return {r,c};
  }

  function resetGame(){
    parseMap();
    score = 0;
    lives = 3;
    powerLeft = 0;

    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    const home = findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p = findOpenNear(home.r, home.c + (i%2===0 ? -1 : 1));
      g.r = p.r; g.c = p.c;
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
      g.patrolIndex = i % patrolCorners.length;
    });

    running = true;
    lastTime = performance.now();
    syncHUD();
  }

  // ===== AI =====
  function dist2(a,b){
    const dr = a.r - b.r, dc = a.c - b.c;
    return dr*dr + dc*dc;
  }
  function chooseDirToward(entity, target, avoidOpposite=true){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0], bestScore = Infinity;
    for (const d of options){
      if (avoidOpposite && d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s < bestScore){ bestScore = s; best = d; }
    }
    return best;
  }
  function chooseDirAway(entity, target){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0], bestScore = -Infinity;
    for (const d of options){
      if (d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s > bestScore){ bestScore = s; best = d; }
    }
    return best;
  }
  function getGhostTarget(g){
    const pr = Math.round(player.r);
    const pc = Math.round(player.c);

    if (g.base === "chaser") return {r: pr, c: pc};

    if (g.base === "ambush"){
      const pd = player.dir;
      let tr = pr + pd.dr * 4;
      let tc = pc + pd.dc * 4;
      tr = Math.max(1, Math.min(ROWS-2, tr));
      if (tc < 0) tc = COLS-1;
      if (tc >= COLS) tc = 0;
      return {r: tr, c: tc};
    }

    if (g.base === "patrol"){
      const me = {r: Math.round(g.r), c: Math.round(g.c)};
      const playerHere = {r: pr, c: pc};
      if (dist2(me, playerHere) <= 36) return playerHere;
      const corner = patrolCorners[g.patrolIndex];
      if (dist2(me, corner) <= 4) g.patrolIndex = (g.patrolIndex + 1) % patrolCorners.length;
      return patrolCorners[g.patrolIndex];
    }

    return {r: pr, c: pc};
  }

  // ===== Movement =====
  function stepEntity(ent, dt, speed){
    const move = speed * dt;

    if (atCenter(ent.r) && atCenter(ent.c)){
      const r = Math.round(ent.r);
      const c = Math.round(ent.c);

      if (ent === player){
        if (canMove(r,c,ent.nextDir)) ent.dir = ent.nextDir;
        else if (!canMove(r,c,ent.dir)) ent.dir = DIRS.none;
      } else {
        if (ent.respawn > 0){
          ent.dir = chooseDirToward(ent, ghostHome, true);
        } else if (powerLeft > 0){
          ent.dir = chooseDirAway(ent, {r: Math.round(player.r), c: Math.round(player.c)});
        } else {
          if (ent.base === "random"){
            const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
            const filtered = options.filter(d => d !== opposite(ent.dir));
            const list = (filtered.length ? filtered : options);
            if (list.length) ent.dir = list[Math.floor(Math.random()*list.length)];
          } else {
            ent.dir = chooseDirToward(ent, getGhostTarget(ent), true);
          }
        }
      }
    }

    let nr = ent.r + ent.dir.dr * move;
    let nc = ent.c + ent.dir.dc * move;

    if (nc < 0) nc = COLS - 0.01;
    if (nc >= COLS) nc = 0.01;

    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      } else {
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  // ===== Eat / collide =====
  function tryEat(){
    const r = Math.round(player.r);
    const c = Math.round(player.c);
    const k = r + "," + c;

    if (leaves.has(k)){
      leaves.delete(k);
      score += 1;
      beep(620, 0.04, "sine", 0.02);
      syncHUD();
    } else if (powers.has(k)){
      powers.delete(k);
      score += 5;
      powerLeft = POWER_TIME;
      beep(220, 0.08, "square", 0.03);
      syncHUD();
    }
  }

  function collide(a,b){
    return Math.abs(a.r - b.r) < 0.45 && Math.abs(a.c - b.c) < 0.45;
  }

  function onPlayerHit(){
    lives -= 1;
    beep(140, 0.20, "sawtooth", 0.02);
    if (lives <= 0){ gameOver(); return; }

    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    const home = findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p = findOpenNear(home.r, home.c + (i%2===0 ? -1 : 1));
      g.r = p.r; g.c = p.c;
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
    });

    powerLeft = 0;
    syncHUD();
  }

  function gameOver(){
    running = false;
    syncHUD();
    updateLB(nickName, score);
    modalTitle.textContent = "éŠæˆ²çµæŸï¼";
    modalText.textContent = `ä½ çš„åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  function win(){
    running = false;
    updateLB(nickName, score);
    modalTitle.textContent = "é€šé—œæˆåŠŸï¼";
    modalText.textContent = `ä½ æŠŠå«©è‘‰é»éƒ½åƒå…‰å•¦ï¼åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  // ===== Drawing =====
  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  function drawGiraffeBackground(){
    ctx.fillStyle = css("--giraffe-base");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const spotA = css("--spotA");
    const spotB = css("--spotB");
    for (let i=0;i<90;i++){
      const x = (i*97 % canvas.width);
      const y = (i*53 % canvas.height);
      const r = 14 + (i*7 % 18);
      ctx.fillStyle = (i%3===0) ? spotA : spotB;
      ctx.globalAlpha = 0.16;
      ctx.beginPath();
      ctx.ellipse(x, y, r*1.1, r*0.8, (i%10)*0.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    const v = ctx.createRadialGradient(canvas.width*0.5, canvas.height*0.45, 80, canvas.width*0.5, canvas.height*0.45, canvas.width*0.75);
    v.addColorStop(0, "rgba(0,0,0,0.0)");
    v.addColorStop(1, "rgba(0,0,0,0.30)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // ===== (1) Qç‰ˆçµ¨æ¯›ç‰† + é¹¿é¹¿æ–‘é» + ç«‹é«” =====
  function plushRoundRect(x,y,w,h,r){
    const rr = Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawPlushWallTile(cx, cy, size, seed){
    const base = css("--plush-base");
    const edge = css("--plush-edge");
    const hi   = css("--plush-hi");
    const mid  = css("--plush-mid");
    const sh   = css("--plush-shadow");
    const spotA= css("--spotA");
    const spotB= css("--spotB");

    const x = cx, y = cy, s = size;

    // drop shadow
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = sh;
    plushRoundRect(x+4, y+5, s-8, s-8, 10);
    ctx.fill();
    ctx.globalAlpha = 1;

    // main plush body (gradient)
    const g = ctx.createLinearGradient(x, y, x+s, y+s);
    g.addColorStop(0, hi);
    g.addColorStop(0.35, mid);
    g.addColorStop(1, base);

    ctx.fillStyle = g;
    plushRoundRect(x+2, y+2, s-6, s-6, 10);
    ctx.fill();

    // edge stitch (soft outline)
    ctx.strokeStyle = edge;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.9;
    plushRoundRect(x+2, y+2, s-6, s-6, 10);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // fuzz hairs (Qç‰ˆçµ¨æ¯›å°æ¯›åˆº)
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = hi;
    ctx.lineWidth = 1;
    const n = 6;
    for (let i=0;i<n;i++){
      const t = (seed*17 + i*11) % 1000 / 1000;
      const xx = x + 5 + t*(s-10);
      ctx.beginPath(); ctx.moveTo(xx, y+2); ctx.lineTo(xx, y-2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xx, y+s-4); ctx.lineTo(xx, y+s); ctx.stroke();
    }
    for (let i=0;i<n;i++){
      const t = (seed*23 + i*9) % 1000 / 1000;
      const yy = y + 5 + t*(s-10);
      ctx.beginPath(); ctx.moveTo(x+2, yy); ctx.lineTo(x-2, yy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+s-4, yy); ctx.lineTo(x+s, yy); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // giraffe spots on wall tile (subtle)
    ctx.globalAlpha = 0.22;
    for (let i=0;i<2;i++){
      const rr = 5 + ((seed+i*7)%4);
      const ox = x + 10 + ((seed*13 + i*9) % (s-20));
      const oy = y + 10 + ((seed*19 + i*11) % (s-20));
      ctx.fillStyle = ((seed+i)%2===0) ? spotA : spotB;
      ctx.beginPath();
      ctx.ellipse(ox, oy, rr*1.1, rr*0.8, (seed%10)*0.15, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // inner plush highlight
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = hi;
    ctx.lineWidth = 1.5;
    plushRoundRect(x+6, y+6, s-14, s-14, 9);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawWalls(){
    // çµ¨æ¯›ç‰†ï¼šæ¯æ ¼ tile
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        if (!isWall(r,c)) continue;
        const seed = (r*131 + c*197) >>> 0;
        drawPlushWallTile(c*TILE, r*TILE, TILE, seed);
      }
    }
  }

  // ===== (4) å«©è‘‰é»ï¼šçµ±ä¸€åœ–æ¨£ï¼ˆå–ä»£ç™½åœ“é»ï¼‰=====
  function drawLeafDot(x,y,scale=1){
    const a = css("--dotLeaf");
    const b = css("--dotLeaf2");

    // tiny stem
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = b;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x-1, y+3);
    ctx.lineTo(x+2, y+6);
    ctx.stroke();

    // two leaves
    ctx.fillStyle = a;
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.ellipse(x-2, y, 4*scale, 2.6*scale, -0.7, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+2, y+1, 4*scale, 2.6*scale, 0.7, 0, Math.PI*2);
    ctx.fill();

    // highlight
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.ellipse(x-2, y-0.5, 1.6*scale, 0.9*scale, -0.7, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawLeaves(){
    leaves.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      drawLeafDot(x,y,1);
    });
  }

  // ===== (3) èƒ½é‡æœï¼šæ›´é¡¯çœ¼ï¼ˆé‡‘è‰²æœ + å…‰æšˆ + å°è‘‰ï¼‰=====
  function drawPowerFruit(x,y,phase){
    const g1 = css("--powerGold");
    const g2 = css("--powerGold2");

    // glow ring
    const pulse = 0.5 + 0.5*Math.sin(phase);
    ctx.globalAlpha = 0.25 + 0.18*pulse;
    ctx.fillStyle = g1;
    ctx.beginPath();
    ctx.arc(x,y, 13 + 2*pulse, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // fruit body gradient
    const grad = ctx.createRadialGradient(x-3,y-4,2, x,y,10);
    grad.addColorStop(0, "#fff1c2");
    grad.addColorStop(0.4, g1);
    grad.addColorStop(1, g2);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(x,y,9.5,10.5,0,0,Math.PI*2);
    ctx.fill();

    // shine
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.ellipse(x-3.5,y-4.5,2.3,1.6,0,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // leaf on top
    ctx.fillStyle = css("--dotLeaf");
    ctx.beginPath();
    ctx.ellipse(x+4,y-10,4,2.4, -0.5, 0, Math.PI*2);
    ctx.fill();
  }

  function drawPowers(timeSec){
    powers.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      drawPowerFruit(x,y, timeSec*5 + r*0.7 + c*0.3);
    });
  }

  function drawSprite(img, x, y, size, fallbackColor="#ffffff"){
    if (img){
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      return;
    }
    ctx.fillStyle = fallbackColor;
    ctx.beginPath();
    ctx.arc(x, y, size/2, 0, Math.PI*2);
    ctx.fill();
  }

  function draw(timeSec){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    drawGiraffeBackground();
    drawWalls();
    drawLeaves();
    drawPowers(timeSec);

    // player (gold aura when powered)
    if (powerLeft > 0){
      const px = player.c*TILE + TILE/2;
      const py = player.r*TILE + TILE/2;
      const pulse = 0.5 + 0.5*Math.sin(timeSec*8);
      ctx.globalAlpha = 0.28 + 0.22*pulse;
      ctx.fillStyle = css("--powerGold");
      ctx.beginPath();
      ctx.arc(px,py, 16 + 2*pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    drawSprite(images.player, player.c*TILE + TILE/2, player.r*TILE + TILE/2, 26, "#ffd26a");

    ghosts.forEach(g=>{
      const colorMap = { dad:"#ff6b6b", mom:"#ff9bd6", water:"#7dffbf", angry:"#ffb36b" };

      if (g.respawn > 0) ctx.globalAlpha = 0.55;
      drawSprite(images[g.imgKey], g.c*TILE + TILE/2, g.r*TILE + TILE/2, 26, colorMap[g.imgKey] || "#ffffff");

      // âœ… å¼·åŒ–æ™‚ï¼šæ•µäººå¼±åŒ–å¯ç›®è¦–ï¼ˆè—è‰²åœˆï¼‰
      if (powerLeft > 0 && g.respawn <= 0){
        const gx = g.c*TILE + TILE/2;
        const gy = g.r*TILE + TILE/2;
        const pulse = 0.5 + 0.5*Math.sin(timeSec*7 + (g.c+g.r));
        ctx.globalAlpha = 0.18 + 0.12*pulse;
        ctx.fillStyle = "#3aa0ff";
        ctx.beginPath();
        ctx.arc(gx,gy, 15 + 2*pulse, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    });

    if (powerLeft > 0){
      ctx.globalAlpha = 0.72;
      ctx.fillStyle = css("--deep");
      ctx.fillRect(6, 8, 170, 22);
      ctx.globalAlpha = 1;
      ctx.fillStyle = css("--powerGold");
      ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "left";
      ctx.fillText("å¼·åŒ–ï¼š" + powerLeft.toFixed(1) + "s", 10, 25);
    }
  }

  // ===== Movement / loop =====
  function collide(a,b){
    return Math.abs(a.r - b.r) < 0.45 && Math.abs(a.c - b.c) < 0.45;
  }

  function tryEat(){
    const r = Math.round(player.r);
    const c = Math.round(player.c);
    const k = r + "," + c;

    if (leaves.has(k)){
      leaves.delete(k);
      score += 1;
      beep(620, 0.04, "sine", 0.02);
      syncHUD();
    } else if (powers.has(k)){
      powers.delete(k);
      score += 5;
      powerLeft = POWER_TIME;
      beep(240, 0.09, "square", 0.03);
      syncHUD();
    }
  }

  function dist2(a,b){
    const dr = a.r - b.r, dc = a.c - b.c;
    return dr*dr + dc*dc;
  }
  function chooseDirToward(entity, target, avoidOpposite=true){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0], bestScore = Infinity;
    for (const d of options){
      if (avoidOpposite && d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s < bestScore){ bestScore = s; best = d; }
    }
    return best;
  }
  function chooseDirAway(entity, target){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0], bestScore = -Infinity;
    for (const d of options){
      if (d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s > bestScore){ bestScore = s; best = d; }
    }
    return best;
  }
  function getGhostTarget(g){
    const pr = Math.round(player.r);
    const pc = Math.round(player.c);

    if (g.base === "chaser") return {r: pr, c: pc};

    if (g.base === "ambush"){
      const pd = player.dir;
      let tr = pr + pd.dr * 4;
      let tc = pc + pd.dc * 4;
      tr = Math.max(1, Math.min(ROWS-2, tr));
      if (tc < 0) tc = COLS-1;
      if (tc >= COLS) tc = 0;
      return {r: tr, c: tc};
    }

    if (g.base === "patrol"){
      const me = {r: Math.round(g.r), c: Math.round(g.c)};
      const playerHere = {r: pr, c: pc};
      if (dist2(me, playerHere) <= 36) return playerHere;
      const corner = patrolCorners[g.patrolIndex];
      if (dist2(me, corner) <= 4) g.patrolIndex = (g.patrolIndex + 1) % patrolCorners.length;
      return patrolCorners[g.patrolIndex];
    }

    return {r: pr, c: pc};
  }

  function stepEntity(ent, dt, speed){
    const move = speed * dt;

    if (atCenter(ent.r) && atCenter(ent.c)){
      const r = Math.round(ent.r);
      const c = Math.round(ent.c);

      if (ent === player){
        if (canMove(r,c,ent.nextDir)) ent.dir = ent.nextDir;
        else if (!canMove(r,c,ent.dir)) ent.dir = DIRS.none;
      } else {
        if (ent.respawn > 0){
          ent.dir = chooseDirToward(ent, ghostHome, true);
        } else if (powerLeft > 0){
          ent.dir = chooseDirAway(ent, {r: Math.round(player.r), c: Math.round(player.c)});
        } else {
          if (ent.base === "random"){
            const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
            const filtered = options.filter(d => d !== opposite(ent.dir));
            const list = (filtered.length ? filtered : options);
            if (list.length) ent.dir = list[Math.floor(Math.random()*list.length)];
          } else {
            ent.dir = chooseDirToward(ent, getGhostTarget(ent), true);
          }
        }
      }
    }

    let nr = ent.r + ent.dir.dr * move;
    let nc = ent.c + ent.dir.dc * move;

    if (nc < 0) nc = COLS - 0.01;
    if (nc >= COLS) nc = 0.01;

    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      } else {
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  function onPlayerHit(){
    lives -= 1;
    beep(140, 0.20, "sawtooth", 0.02);
    if (lives <= 0){ gameOver(); return; }

    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    const home = findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p = findOpenNear(home.r, home.c + (i%2===0 ? -1 : 1));
      g.r = p.r; g.c = p.c;
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
    });

    powerLeft = 0;
    syncHUD();
  }

  function gameOver(){
    running = false;
    syncHUD();
    updateLB(nickName, score);
    modalTitle.textContent = "éŠæˆ²çµæŸï¼";
    modalText.textContent = `ä½ çš„åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  function win(){
    running = false;
    updateLB(nickName, score);
    modalTitle.textContent = "é€šé—œæˆåŠŸï¼";
    modalText.textContent = `ä½ æŠŠå«©è‘‰é»éƒ½åƒå…‰å•¦ï¼åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  function drawSprite(img, x, y, size, fallbackColor="#ffffff"){
    if (img){
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      return;
    }
    ctx.fillStyle = fallbackColor;
    ctx.beginPath();
    ctx.arc(x, y, size/2, 0, Math.PI*2);
    ctx.fill();
  }

  // ===== Inputs / UI =====
  window.addEventListener("keydown", (e)=>{
    ensureAudioUnlocked();
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") player.nextDir = DIRS.up;
    if (k === "arrowdown" || k === "s") player.nextDir = DIRS.down;
    if (k === "arrowleft" || k === "a") player.nextDir = DIRS.left;
    if (k === "arrowright" || k === "d") player.nextDir = DIRS.right;
  }, {passive:true});

  function bindPad(el, dir){
    const set = (ev) => {
      ev.preventDefault();
      ensureAudioUnlocked();
      player.nextDir = dir;
      beep(480, 0.02, "sine", 0.012);
    };
    el.addEventListener("pointerdown", set, {passive:false});
  }
  bindPad(padLeft, DIRS.left);
  bindPad(padUp, DIRS.up);
  bindPad(padRight, DIRS.right);
  bindPad(padDown, DIRS.down);

  btnSound.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    audioEnabled = !audioEnabled;
    btnSound.textContent = audioEnabled ? "ğŸ”Š è²éŸ³ï¼šé–‹" : "ğŸ”‡ è²éŸ³ï¼šé—œ";
    if (audioEnabled) beep(520, 0.05, "sine", 0.02);
  });

  btnRestart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    resetGame();
  });

  btnHelp.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    helpCard.style.display = (helpCard.style.display === "block") ? "none" : "block";
  });
  helpCard.addEventListener("click", (e)=> e.stopPropagation());
  canvas.addEventListener("pointerdown", ()=>{
    if (helpCard.style.display === "block") helpCard.style.display = "none";
  });

  btnStart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    let name = (nameInput.value || "").trim();
    if (!name) name = "é¹¿ç²‰";
    nickName = name.slice(0,12);
    overlay.style.display = "none";
    btnStart.textContent = "é–‹å§‹éŠæˆ²";
    resetGame();
  });

  // ===== Loop =====
  function loop(t){
    if (!running){
      draw(t/1000);
      requestAnimationFrame(loop);
      return;
    }
    const dt = Math.min(0.04, (t - lastTime) / 1000);
    lastTime = t;

    if (powerLeft > 0) powerLeft = Math.max(0, powerLeft - dt);

    stepEntity(player, dt, SPEED_PLAYER);
    tryEat();

    ghosts.forEach(g=>{
      if (g.respawn > 0) g.respawn = Math.max(0, g.respawn - dt);
      const spd = (powerLeft > 0 && g.respawn<=0) ? SPEED_FRIGHT : SPEED_GHOST;
      stepEntity(g, dt, spd);
    });

    for (const g of ghosts){
      if (collide(player,g)){
        if (powerLeft > 0 && g.respawn<=0){
          score += 10;
          beep(820, 0.06, "triangle", 0.03);
          g.respawn = RESPAWN_TIME;
          const home = findOpenNear(ghostHome.r, ghostHome.c);
          g.r = home.r; g.c = home.c;
          g.dir = DIRS.up;
          syncHUD();
        } else if (g.respawn<=0){
          onPlayerHit();
          break;
        }
      }
    }

    if (leaves.size + powers.size === 0) win();

    syncHUD();
    draw(t/1000);
    requestAnimationFrame(loop);
  }

  // ===== init =====
  async function init(){
    renderLB();
    parseMap();
    syncHUD();

    overlay.style.display = "flex";
    running = false;

    await preloadAllImages();
    requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
