<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é˜¿é¹¿é¹¿æ–‡å‰µ-ç²¾éˆé¹¿é¹¿ GOï¼</title>

  <style>
    :root{
      --bg:#fdecef;
      --panel:#ffffff;
      --line:#e6e6e6;
      --text:#222;
      --muted:#666;

      --pill:#f6f6f6;
      --pillText:#222;
      --btn:#111;
      --btnText:#fff;

      /* åœ°åœ–åº•ï¼šæš—æ·¡æ³¥åœŸé»ƒè‰²ç³»ï¼ˆå«æ·¡æ–‘ï¼‰ */
      --mapBase:#D8C07A;
      --mapSpot:#B28B5E;

      /* ç‰†ï¼šé»ƒåº•ï¼‹ç´…æ£•æ¢ç´‹ï¼‹é»‘æ£•é‚Šæ¡†ï¼ˆæ˜é¡¯ï¼‰ */
      --wallBase:#FFD46A;
      --wallStripe:#B2562E;
      --wallBorder:#2B1A12;

      /* å«©è‘‰ */
      --leaf1:#1BFF6B;
      --leaf2:#00B84D;

      /* èƒ½é‡æœ */
      --power1:#FFD100;
      --power2:#FF7A00;

      --blueWeak:#2EA8FF;

      --radius:16px;
      --safeB: env(safe-area-inset-bottom);
      --safeT: env(safe-area-inset-top);
    }

    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC","PingFang TC","Microsoft JhengHei", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: 8px 10px calc(10px + var(--safeB));
      gap:10px;
    }

    /* ===== Top bar ===== */
    .topbar{
      padding-top: var(--safeT);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .brandRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .brand{
      font-weight:900;
      font-size:15px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .pillRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      background: var(--pill);
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 12px;
      font-size:13px;
      color:var(--pillText);
      display:flex;
      align-items:center;
      gap:6px;
      min-height:34px;
    }
    .pill b{font-weight:900}
    .pillBtn{
      cursor:pointer;
      user-select:none;
    }
    .pillBtn:active{transform:translateY(1px)}
    .pillDark{
      background: var(--btn);
      color: var(--btnText);
      border:1px solid #000;
    }

    /* ===== Audio panel ===== */
    .audioPanel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .audioRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .check{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:14px;
    }
    .check input{ width:18px; height:18px; }
    .vol{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 52%;
      justify-content:flex-end;
      color:var(--muted);
      font-size:13px;
    }
    input[type="range"]{
      width: 180px;
      max-width: 46vw;
    }

    /* ===== Name row ===== */
    .nameRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .nameRow input{
      flex:1;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background:#fff;
      font-size:14px;
      outline:none;
    }
    .applyBtn{
      padding:12px 14px;
      border-radius: 14px;
      border:1px solid var(--line);
      background:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .applyBtn:active{transform:translateY(1px)}
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
      padding:0 2px;
    }

    /* ===== Game area ===== */
    .gameWrap{
      flex:1;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    canvas{
      width:100%;
      max-width: 980px;
      height:auto;
      max-height: calc(100vh - 260px - var(--safeT) - var(--safeB));
      border-radius: 18px;
      border:1px solid var(--line);
      background:#000;
      display:block;
      touch-action:none;
      image-rendering: pixelated;
    }

    /* (3) å€’æ•¸ overlay */
    .countdown{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .countdown .bubble{
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
      border-radius: 22px;
      padding: 18px 22px;
      box-shadow: 0 16px 60px rgba(0,0,0,.35);
      min-width: 160px;
      text-align:center;
    }
    .countdown .n{
      font-weight:1000;
      font-size:64px;
      line-height:1;
      color:#fff;
      text-shadow: 0 6px 22px rgba(0,0,0,.35);
    }
    .countdown .t{
      margin-top:8px;
      font-size:13px;
      color: rgba(255,255,255,.9);
      letter-spacing:.08em;
    }

    /* ===== Bottom dpad ===== */
    .dpad{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 56px 56px;
      gap:10px;
      align-items:center;
      justify-items:stretch;
    }
    .padBtn{
      border-radius: 16px;
      border:1px solid var(--line);
      background: #fff;
      font-weight:900;
      font-size:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .padBtn:active{transform:translateY(1px)}
    .padLeft {grid-column:1; grid-row:1;}
    .padUp   {grid-column:2; grid-row:1;}
    .padRight{grid-column:3; grid-row:1;}
    .padDown {grid-column:2; grid-row:2;}

    /* ===== Overlays ===== */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal{
      width:min(92vw, 560px);
      background:#fff;
      border-radius: 18px;
      border:1px solid var(--line);
      padding:14px;
      box-shadow: 0 18px 70px rgba(0,0,0,.35);
    }
    .modalTitle{
      font-weight:900;
      font-size:16px;
      margin:0 0 8px;
    }
    .modalText{
      margin:0 0 10px;
      font-size:13px;
      color:#444;
      line-height:1.45;
    }
    .modalBtns{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:10px;
    }
    .mBtn{
      border-radius: 14px;
      padding:10px 12px;
      font-weight:900;
      border:1px solid var(--line);
      background:#fff;
      cursor:pointer;
    }
    .mBtn.dark{
      background:#111;
      border-color:#111;
      color:#fff;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
    }
    th,td{
      border-bottom:1px solid #eee;
      padding:8px 8px;
      text-align:left;
    }
    th{color:#444; background:#fafafa}

    .smallNote{
      font-size:12px;
      color:#666;
      margin-top:8px;
      line-height:1.35;
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- ===== Topbar ===== -->
    <div class="topbar">
      <div class="brandRow">
        <div>
          <div class="brand">é˜¿é¹¿é¹¿æ–‡å‰µ-ç²¾éˆé¹¿é¹¿ GOï¼</div>
          <div class="sub">ç©å®¶ï¼š<span id="uiName">Guest</span>ã€€|ã€€å€ç‡ï¼šx1</div>
        </div>
      </div>

      <div class="pillRow">
        <div class="pill"><span>åˆ†æ•¸</span> <b id="uiScore">0</b></div>
        <div class="pill"><span>æœ€é«˜</span> <b id="uiBest">0</b></div>

        <div class="pill pillBtn" id="btnLB">æŸ¥è©¢æ’è¡Œæ¦œ</div>
        <div class="pill pillBtn" id="btnHelp">ç©æ³•</div>
        <div class="pill pillBtn pillDark" id="btnStart">é–‹å§‹</div>
      </div>
    </div>

    <!-- ===== Audio Panel ===== -->
    <div class="audioPanel">
      <div class="audioRow">
        <div class="check">
          <input type="checkbox" id="chkBgm" checked />
          <label for="chkBgm">BGM</label>
        </div>
        <div class="vol">
          <span>éŸ³é‡</span>
          <input type="range" id="bgmVol" min="0" max="100" value="55" />
        </div>
      </div>

      <div class="audioRow">
        <div class="check">
          <input type="checkbox" id="chkSfx" checked />
          <label for="chkSfx">éŸ³æ•ˆ</label>
        </div>
        <div class="vol">
          <span>éŸ³é‡</span>
          <input type="range" id="sfxVol" min="0" max="100" value="65" />
        </div>
      </div>

      <div class="nameRow">
        <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆå¯é¸ï¼‰" />
        <button class="applyBtn" id="btnApply">å¥—ç”¨</button>
      </div>

      <div class="hint">
        æ’è¡Œæ¦œä½¿ç”¨ LocalStorageï¼ˆå…å¾Œç«¯ï¼‰ã€‚<br/>
        LINE/iOS éœ€ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚
      </div>
    </div>

    <!-- ===== Game ===== -->
    <div class="gameWrap">
      <canvas id="game" width="840" height="510"></canvas>

      <!-- (3) Start countdown -->
      <div class="countdown" id="countdown">
        <div class="bubble">
          <div class="n" id="cdNum">3</div>
          <div class="t">æº–å‚™é–‹å§‹</div>
        </div>
      </div>
    </div>

    <!-- ===== D-pad ===== -->
    <div class="dpad">
      <div class="padBtn padLeft"  id="padLeft">â†</div>
      <div class="padBtn padUp"    id="padUp">â†‘</div>
      <div class="padBtn padRight" id="padRight">â†’</div>
      <div class="padBtn padDown"  id="padDown">â†“</div>
    </div>
  </div>

  <!-- ===== HELP Overlay ===== -->
  <div class="overlay" id="helpOverlay">
    <div class="modal">
      <div class="modalTitle">é˜¿é¹¿é¹¿æ–‡å‰µ-ç²¾éˆé¹¿é¹¿ GOï¼ï½œç©æ³•</div>
      <div class="modalText">
        ğŸ¦Œ <b>æ“ä½œï¼š</b>æ–¹å‘éµç§»å‹•ï¼ˆæ‰‹æ©Ÿé»ä¸‹æ–¹æ–¹å‘éµï¼›æ¡Œæ©Ÿæ–¹å‘éµ/WASDï¼‰ã€‚<br/>
        ğŸƒ <b>å«©è‘‰é»ï¼š</b>åœ°åœ–ä¸Šçš„ <b>å°å«©è‘‰</b>ï¼Œåƒåˆ° <b>+1 åˆ†</b>ã€‚<br/>
        ğŸ <b>èƒ½é‡æœï¼š</b>åœ°åœ–ä¸Šçš„ <b>é‡‘è‰²èƒ½é‡æœ</b>ï¼Œåƒåˆ° <b>+5 åˆ†</b>ï¼Œä¸¦é€²å…¥ <b>å¼·åŒ–æ¨¡å¼ï¼ˆ7 ç§’ï¼‰</b>ã€‚<br/><br/>
        âš¡ <b>å¼·åŒ–æ¨¡å¼ï¼ˆ7 ç§’ï¼‰ï¼š</b><br/>
        ãƒ»ä½ èº«ä¸Šæœƒæœ‰ <b>æ›´æ˜é¡¯çš„é‡‘è‰²å…‰äº®/å…‰ç’°</b>ï¼ˆHUD æœƒé¡¯ç¤ºã€Œå¼·åŒ–ã€ï¼‰ã€‚<br/>
        ãƒ»æ•µäººæœƒå‡ºç¾ <b>è—è‰²å¼±åŒ–å…‰åœˆ</b>ï¼Œä¸” <b>ç§»å‹•é€Ÿåº¦é™ä½</b>ï¼ˆå¯ç›®è¦–ï¼‰ã€‚<br/>
        ãƒ»ç¢°åˆ°å¼±åŒ–æ•µäººå¯ <b>ååƒ +10 åˆ†</b>ã€‚<br/><br/>
        ğŸ’¥ <b>å¤±æ•—ï¼š</b>éå¼·åŒ–æ™‚ç¢°åˆ°æ•µäººï¼š<b>-1 ç”Ÿå‘½</b>ä¸¦é‡ç”Ÿã€‚<br/>
        âœ¨ <b>é‡ç”Ÿç„¡æ•µï¼š</b>æ¯æ¬¡é‡ç”Ÿå¾Œæœ‰ <b>3 ç§’ç„¡æ•µ</b>ï¼ˆä½ èº«ä¸Šæœƒæœ‰ <b>ç‰¹æ®Šå…‰äº®</b>ï¼Œé¿å…å‰›é‡ç”Ÿå°±è¢«ç¢°åˆ°ï¼‰ã€‚<br/><br/>
        ğŸƒ <b>é€Ÿåº¦èªªæ˜ï¼š</b><br/>
        ãƒ»ç©å®¶é€Ÿåº¦ï¼š<b>å›ºå®š</b>ã€‚<br/>
        ãƒ»æ•µäººé€Ÿåº¦ï¼šé–‹å±€ç‚ºç©å®¶çš„ <b>75%</b>ï¼Œæœƒéš¨éŠæˆ²æ™‚é–“é€æ­¥å¢åŠ ï¼Œä¸Šé™ <b>ä¸è¶…éç©å®¶ 95%</b>ã€‚<br/>
        ãƒ»å¼±åŒ–ï¼ˆå¼·åŒ–æœŸé–“ï¼‰æ•µäººé€Ÿåº¦ï¼šæœƒå†é™ä½ã€‚<br/>
      </div>
      <div class="modalBtns">
        <button class="mBtn" id="helpClose">é—œé–‰</button>
        <button class="mBtn dark" id="helpStart">é–‹å§‹éŠæˆ²</button>
      </div>
    </div>
  </div>

  <!-- ===== Leaderboard Overlay ===== -->
  <div class="overlay" id="lbOverlay">
    <div class="modal">
      <div class="modalTitle">æ’è¡Œæ¦œï¼ˆä¿ç•™ 7 å¤©ï¼Œåƒ…é¡¯ç¤ºå‰ 6 åï¼‰</div>
      <div class="modalText" id="lbHint"></div>
      <div style="max-height:260px; overflow:auto; border:1px solid #eee; border-radius:12px;">
        <table>
          <thead><tr><th>#</th><th>æš±ç¨±</th><th>åˆ†æ•¸</th><th>æ—¥æœŸ</th></tr></thead>
          <tbody id="lbBody"></tbody>
        </table>
      </div>
      <div class="smallNote">æç¤ºï¼šåˆ†æ•¸è¶Šé«˜è¶Šå‰é¢ï¼›è¶…é 7 å¤©çš„ç´€éŒ„æœƒè‡ªå‹•æ¸…é™¤ã€‚</div>
      <div class="modalBtns">
        <button class="mBtn dark" id="lbClose">é—œé–‰</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Assets =====
  const IMG = {
    player: "https://raw.githubusercontent.com/z883662/Aruru/main/lulu1.png",
    dad:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu2.png",
    mom:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu3.png",
    water:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu4.png",
    angry:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu5.png",
  };

  // ===== Base Map (template) =====
  // '.'=å«©è‘‰é», 'o'=èƒ½é‡æœ, 'P'=ç©å®¶, 'G'=é¬¼å‡ºç”Ÿ
  const BASE_MAP = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.#####.##.#####.######",
    "#....#.#####.##.#####.#....#",
    "######.##..####..##.########",
    "#..........##..G..##.......#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "#......##....P.....##......#",
    "############################",
  ];

  // ===== DOM =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const uiName  = document.getElementById("uiName");
  const uiScore = document.getElementById("uiScore");
  const uiBest  = document.getElementById("uiBest");

  const btnStart = document.getElementById("btnStart");
  const btnHelp  = document.getElementById("btnHelp");
  const btnLB    = document.getElementById("btnLB");

  const chkBgm = document.getElementById("chkBgm");
  const chkSfx = document.getElementById("chkSfx");
  const bgmVol = document.getElementById("bgmVol");
  const sfxVol = document.getElementById("sfxVol");

  const nameInput = document.getElementById("nameInput");
  const btnApply  = document.getElementById("btnApply");

  const padLeft  = document.getElementById("padLeft");
  const padUp    = document.getElementById("padUp");
  const padRight = document.getElementById("padRight");
  const padDown  = document.getElementById("padDown");

  const helpOverlay = document.getElementById("helpOverlay");
  const helpClose   = document.getElementById("helpClose");
  const helpStart   = document.getElementById("helpStart");

  const lbOverlay = document.getElementById("lbOverlay");
  const lbClose   = document.getElementById("lbClose");
  const lbBody    = document.getElementById("lbBody");
  const lbHint    = document.getElementById("lbHint");

  const countdownEl = document.getElementById("countdown");
  const cdNumEl = document.getElementById("cdNum");

  // ===== Utils =====
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function escapeHtml(s){ return (s+"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function fmtDate(ts){
    const d = new Date(ts);
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }

  // ===== Leaderboard =====
  const LB_KEY = "aruru_maze_lb_v1";
  const KEEP_MS = 7*24*60*60*1000;

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      const now = Date.now();
      return (Array.isArray(arr)?arr:[])
        .filter(x => x && typeof x.name==="string" && typeof x.score==="number" && typeof x.ts==="number" && (now - x.ts) <= KEEP_MS)
        .sort((a,b)=> b.score - a.score || b.ts - a.ts)
        .slice(0,6);
    }catch(e){ return []; }
  }
  function saveLB(arr){ try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch(e){} }
  function addLB(name, score){
    const now = Date.now();
    let lb = loadLB();
    lb.push({name, score, ts: now});
    lb.sort((a,b)=> b.score - a.score || b.ts - a.ts);
    lb = lb.slice(0,6);
    saveLB(lb);
    renderLB();
    updateBest();
  }
  function renderLB(){
    const lb = loadLB();
    lbHint.textContent = lb.length ? "ç›®å‰æ’è¡Œæ¦œå¦‚ä¸‹ï¼š" : "ç›®å‰æ²’æœ‰ç´€éŒ„ï¼ˆä½ æœƒæ˜¯ç¬¬ä¸€åï¼‰";
    lbBody.innerHTML = lb.map((r,i)=>(
      `<tr><td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${r.score}</td><td>${fmtDate(r.ts)}</td></tr>`
    )).join("") || `<tr><td colspan="4" style="color:#777">ç›®å‰æ²’æœ‰ç´€éŒ„</td></tr>`;
  }
  function updateBest(){
    const lb = loadLB();
    uiBest.textContent = lb.length ? lb[0].score : 0;
  }

  // ===== Audio =====
  let audioCtx = null;
  let unlocked = false;

  let bgmOn = true;
  let sfxOn = true;

  let bgmGain = null;
  let bgmTimer = null;
  let bgmNextTime = 0;
  let bgmStep = 0;

  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    unlocked = true;
  }
  window.addEventListener("pointerdown", ensureAudio, {passive:true});

  function setBgmVolume(){
    const v = (Number(bgmVol.value)||0)/100;
    if (bgmGain) bgmGain.gain.value = v * 0.14;
  }

  function midiToHz(m){ return 440*Math.pow(2,(m-69)/12); }

  function playTone(freq, t0, dur, type, gain){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0001, gain), t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    o.connect(g).connect(bgmGain);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  function scheduleBgm(){
    if (!audioCtx || !bgmGain) return;

    const tempo = 132;
    const stepDur = 60/tempo/2;
    const lookAhead = 0.12;
    const now = audioCtx.currentTime;

    const melody = [
      72, 76, 79, 76, 74, 76, 72, 0,
      72, 76, 79, 84, 83, 79, 76, 0
    ];
    const bass = [
      48, 0, 48, 0, 50, 0, 50, 0,
      45, 0, 45, 0, 43, 0, 43, 0
    ];

    while (bgmNextTime < now + lookAhead){
      const idx = bgmStep % melody.length;

      const m = melody[idx];
      if (m){
        const f = midiToHz(m);
        playTone(f, bgmNextTime, stepDur*0.92, "square", 0.08);
        playTone(f*2, bgmNextTime, stepDur*0.55, "triangle", 0.03);
      }
      const b = bass[idx];
      if (b){
        playTone(midiToHz(b), bgmNextTime, stepDur*0.95, "sine", 0.05);
      }

      bgmNextTime += stepDur;
      bgmStep++;
    }
  }

  function startBgm(){
    if (!unlocked || !bgmOn) return;
    if (bgmTimer) return;

    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.0001;
    bgmGain.connect(audioCtx.destination);
    setBgmVolume();

    bgmNextTime = audioCtx.currentTime + 0.04;
    bgmStep = 0;
    bgmTimer = setInterval(scheduleBgm, 25);
  }

  function stopBgm(){
    if (bgmTimer){ clearInterval(bgmTimer); bgmTimer = null; }
    if (bgmGain){
      const t = audioCtx.currentTime;
      try{
        bgmGain.gain.cancelScheduledValues(t);
        bgmGain.gain.setValueAtTime(bgmGain.gain.value, t);
        bgmGain.gain.exponentialRampToValueAtTime(0.0001, t+0.15);
      }catch(e){}
      setTimeout(()=>{ try{ bgmGain.disconnect(); }catch(e){} }, 220);
      bgmGain = null;
    }
  }

  function sfxBeep(freq=520, dur=0.05, type="sine"){
    if (!unlocked || !sfxOn) return;
    const v = (Number(sfxVol.value)||0)/100;
    const g0 = 0.03 * v;

    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(Math.max(0.0001, g0), t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  chkBgm.addEventListener("change", ()=>{
    bgmOn = chkBgm.checked;
    ensureAudio();
    if (bgmOn) startBgm(); else stopBgm();
  });
  chkSfx.addEventListener("change", ()=>{ sfxOn = chkSfx.checked; });
  bgmVol.addEventListener("input", ()=>{ setBgmVolume(); });

  // ===== Images preload =====
  const images = {};
  function loadImage(src, timeoutMs=15000){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      const timer = setTimeout(()=>{ cleanup(); reject(new Error("timeout")); }, timeoutMs);
      function cleanup(){ clearTimeout(timer); im.onload=null; im.onerror=null; }
      im.onload = ()=>{ cleanup(); resolve(im); };
      im.onerror = ()=>{ cleanup(); reject(new Error("error")); };
      im.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
    });
  }
  async function preloadImages(){
    const entries = Object.entries(IMG);
    for (const [k,src] of entries){
      try{ images[k] = await loadImage(src); }
      catch(e){ images[k] = null; }
    }
  }

  // ===== Map state =====
  const TILE = 30;

  let currentMap = BASE_MAP.slice();
  let ROWS = currentMap.length;
  let COLS = currentMap[0].length;

  const grid = [];
  const leaves = new Set();
  const powers = new Set();
  let playerStart = {r:0,c:0};
  let ghostHome = {r:0,c:0};

  canvas.width = COLS*TILE;
  canvas.height = ROWS*TILE;

  // ===== Game constants =====
  const SPEED_PLAYER = 5.2;
  const GHOST_MIN_RATIO = 0.75;
  const GHOST_MAX_RATIO = 0.95;
  const GHOST_RAMP_SECS = 110;

  const POWER_TIME = 7.0;
  const INVINCIBLE_TIME = 3.0;
  const WEAK_RATIO = 0.72;
  const RESPAWN_TIME = 1.2;

  // ===== (1) éš¨æ©Ÿè¿·å®®ï¼šç›¡é‡ä¸è¦æ­»è·¯ï¼ˆæ¡ã€Œå¯æ§æ‰“æ´ã€+ã€Œæ­»è·¯ä¿®è£œã€ï¼‰ =====
  const RAND = {
    maxHoleOpens: 28,     // æ‰“é–‹ç‰†ï¼ˆé™ä½æ­»è·¯ç”¨ï¼‰
    attempts: 380,
    protectRadius: 1,
    // æ­»è·¯ä¿®è£œæ¬¡æ•¸ä¸Šé™ï¼ˆè¶Šå¤§è¶Šå°‘æ­»è·¯ï¼Œä½†è¶Šåƒã€Œé–‹æ”¾åœ°åœ–ã€ï¼‰
    deadendFixPasses: 2
  };

  function k(r,c){ return r+","+c; }

  function buildProtectedMask(mapArr){
    const prot = Array.from({length:ROWS}, ()=> Array(COLS).fill(false));
    const important = [];
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const ch = mapArr[r][c];
        if (ch==="P" || ch==="G" || ch==="o"){
          important.push({r,c});
        }
      }
    }
    for (const p of important){
      for (let dr=-RAND.protectRadius; dr<=RAND.protectRadius; dr++){
        for (let dc=-RAND.protectRadius; dc<=RAND.protectRadius; dc++){
          const rr=p.r+dr, cc=p.c+dc;
          if (rr>=0 && rr<ROWS && cc>=0 && cc<COLS) prot[rr][cc]=true;
        }
      }
    }
    for (let r=0;r<ROWS;r++){ prot[r][0]=true; prot[r][COLS-1]=true; }
    for (let c=0;c<COLS;c++){ prot[0][c]=true; prot[ROWS-1][c]=true; }
    return prot;
  }

  function bfsReachable(mapArr){
    let sr=0, sc=0;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (mapArr[r][c]==="P"){ sr=r; sc=c; break; }
      }
    }
    const q = [{r:sr,c:sc}];
    const vis = Array.from({length:ROWS}, ()=> Array(COLS).fill(false));
    vis[sr][sc]=true;
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    while(q.length){
      const cur=q.shift();
      for (const [dr,dc] of dirs){
        const rr=cur.r+dr;
        let cc=cur.c+dc;
        if (cc<0) cc=COLS-1;
        if (cc>=COLS) cc=0;
        if (rr<0 || rr>=ROWS) continue;
        if (vis[rr][cc]) continue;
        if (mapArr[rr][cc]==="#") continue;
        vis[rr][cc]=true;
        q.push({r:rr,c:cc});
      }
    }
    return vis;
  }

  function isAllImportantReachable(mapArr){
    const vis = bfsReachable(mapArr);
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const ch = mapArr[r][c];
        if ((ch==="G" || ch==="o") && !vis[r][c]) return false;
      }
    }
    let edible=0;
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const ch = mapArr[r][c];
        if ((ch==="." || ch==="o") && vis[r][c]) edible++;
      }
    }
    return edible >= 18;
  }

  function passable(mapArr,r,c){
    if (r<0 || r>=ROWS) return false;
    if (c<0 || c>=COLS) return false;
    return mapArr[r][c] !== "#";
  }

  function degree4(mapArr,r,c){
    // tunnel wrap on left/right
    let deg=0;
    const up = (r-1>=0) ? passable(mapArr,r-1,c) : false;
    const down = (r+1<ROWS) ? passable(mapArr,r+1,c) : false;
    const left = passable(mapArr,r,(c-1+COLS)%COLS);
    const right= passable(mapArr,r,(c+1)%COLS);
    if (up) deg++;
    if (down) deg++;
    if (left) deg++;
    if (right) deg++;
    return deg;
  }

  function fixDeadEnds(mapArr, prot){
    // ç›®æ¨™ï¼šæŠŠã€Œåº¦æ•¸=1ã€çš„æ­»è·¯ï¼Œæ‰“é–‹ç›¸é„°ç‰†ä¸€æ ¼ï¼ˆå½¢æˆå›è·¯ï¼‰
    // æ³¨æ„ï¼šä¸æœƒåšåˆ°100%ç„¡æ­»è·¯ï¼ˆå¤ªå®¹æ˜“æŠŠè¿·å®®æ‰“å¤ªé–‹ï¼‰ï¼Œä½†æœƒã€Œç›¡é‡é™ä½ã€
    let changed=0;
    const candidates=[];
    for (let r=1;r<ROWS-1;r++){
      for (let c=0;c<COLS;c++){
        if (prot[r][c]) continue;
        const ch = mapArr[r][c];
        if (ch==="#" ) continue;
        const deg = degree4(mapArr,r,c);
        if (deg===1) candidates.push({r,c});
      }
    }

    // éš¨æ©Ÿæ‰“æ•£
    for (let i=candidates.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [candidates[i],candidates[j]]=[candidates[j],candidates[i]];
    }

    const dirs = [
      {dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}
    ];

    for (const cell of candidates){
      const r=cell.r, c=cell.c;
      if (degree4(mapArr,r,c)!==1) continue;

      // æ‰¾ä¸€é¢ç‰†å¯ä»¥æ‰“é€šï¼ˆå„ªå…ˆï¼šæ‰“é€šå¾Œæœƒé€£åˆ°ã€Œå·²å¯èµ°å€ã€ï¼‰
      const vis = bfsReachable(mapArr);

      let best=null, bestScore=-1;
      for (const d of dirs){
        const rr=r+d.dr;
        let cc=c+d.dc;
        if (cc<0) cc=COLS-1;
        if (cc>=COLS) cc=0;
        if (rr<=0 || rr>=ROWS-1) continue;
        if (prot[rr][cc]) continue;

        if (mapArr[rr][cc] !== "#") continue; // åªæ‰“ç‰†
        // æ‰“é€šå¾Œçš„ä½ç½®
        // åˆ†æ•¸ï¼šè‹¥æ‰“é€šæœƒç›´æ¥æ¥åˆ°å¯é”å€ï¼ˆvis trueï¼‰åŠ åˆ†
        let score = 0;
        // ç‰†çš„å¦ä¸€å´ï¼ˆå†å¾€å‰ä¸€æ ¼ï¼‰å¦‚æœæ˜¯å¯èµ°å€ï¼Œä»£è¡¨æœ‰æ©Ÿæœƒå½¢æˆç’°
        const r2=rr+d.dr;
        let c2=cc+d.dc;
        if (c2<0) c2=COLS-1;
        if (c2>=COLS) c2=0;
        if (r2>0 && r2<ROWS-1 && mapArr[r2][c2] !== "#") score += 2;
        if (vis[rr][cc]) score += 3; // æœ¬èº«è®Šæˆå¯é”ï¼ˆæ‰“é€šç•¶ç„¶æœƒï¼‰
        // é¿å…é–‹å¤ªå¤§ï¼šè‹¥æ‰“é€šæœƒè®“åº¦æ•¸è®Šæˆ 3/4 å¤ªå¤šï¼Œå°‘åŠ 
        // ï¼ˆä¼°ç®—ï¼šæŠŠç‰†è®Šè·¯å¾Œé‚£æ ¼çš„ degï¼‰
        // å…ˆæš«æ™‚ç®—ï¼šè‹¥è®Šæˆ '.'ï¼Œå®ƒå‘¨åœå¯èµ°æ ¼æ•¸
        let estDeg=0;
        const up = (rr-1>=0) ? (mapArr[rr-1][cc] !== "#") : false;
        const down = (rr+1<ROWS) ? (mapArr[rr+1][cc] !== "#") : false;
        const left = (mapArr[rr][(cc-1+COLS)%COLS] !== "#");
        const right= (mapArr[rr][(cc+1)%COLS] !== "#");
        if (up) estDeg++;
        if (down) estDeg++;
        if (left) estDeg++;
        if (right) estDeg++;
        score += (estDeg<=2)?1:0;

        if (score>bestScore){ bestScore=score; best={rr,cc}; }
      }

      if (!best) continue;

      // å…ˆè©¦æ‰“é€šï¼Œæª¢æŸ¥å¯é”æ€§ä»æˆç«‹
      const row = mapArr[best.rr];
      const testRow = row.slice(0,best.cc) + "." + row.slice(best.cc+1);
      const testMap = mapArr.slice();
      testMap[best.rr] = testRow;

      if (!isAllImportantReachable(testMap)) continue;

      mapArr = testMap;
      changed++;
    }
    return {mapArr, changed};
  }

  function randomizeMap(){
    // ä»¥ BASE_MAP ç‚ºåŸºåº•ï¼šåªã€Œæ‰“é–‹ã€éƒ¨åˆ†ç‰†ï¼Œä¸¦åšæ­»è·¯ä¿®è£œ
    let mapArr = BASE_MAP.slice();
    ROWS = mapArr.length;
    COLS = mapArr[0].length;

    const prot = buildProtectedMask(mapArr);

    // å€™é¸ç‰†ï¼šå…§éƒ¨ç‰†
    const walls=[];
    for (let r=1;r<ROWS-1;r++){
      for (let c=1;c<COLS-1;c++){
        if (prot[r][c]) continue;
        if (mapArr[r][c]==="#") walls.push({r,c});
      }
    }

    // éš¨æ©Ÿæ‰“æ•£
    for (let i=walls.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [walls[i],walls[j]]=[walls[j],walls[i]];
    }

    let opened=0;
    for (let i=0;i<RAND.attempts && opened<RAND.maxHoleOpens && i<walls.length;i++){
      const w=walls[i];
      const r=w.r, c=w.c;

      // åªæ‰“é–‹é‚£äº›ã€Œæ‰“é–‹å¾Œä¸æœƒè®Šæˆå¤ªç›´é€šã€ï¼šç°¡å–®é™åˆ¶ï¼ˆå‘¨åœè‡³å°‘æœ‰2é¢ç‰†ï¼‰
      let neighWall=0;
      const up = (mapArr[r-1][c]==="#");
      const down=(mapArr[r+1][c]==="#");
      const left=(mapArr[r][c-1]==="#");
      const right=(mapArr[r][c+1]==="#");
      if (up) neighWall++;
      if (down) neighWall++;
      if (left) neighWall++;
      if (right) neighWall++;

      if (neighWall<2) continue;

      const row = mapArr[r];
      const testRow = row.slice(0,c) + "." + row.slice(c+1);
      const testMap = mapArr.slice();
      testMap[r] = testRow;

      if (!isAllImportantReachable(testMap)) continue;

      mapArr = testMap;
      opened++;
    }

    // æ­»è·¯ä¿®è£œï¼ˆå¤šè¼ªï¼‰
    for (let p=0;p<RAND.deadendFixPasses;p++){
      const res = fixDeadEnds(mapArr, prot);
      mapArr = res.mapArr;
      if (res.changed===0) break;
    }

    currentMap = mapArr;
  }

  function parseMap(){
    ROWS = currentMap.length;
    COLS = currentMap[0].length;

    canvas.width = COLS*TILE;
    canvas.height = ROWS*TILE;

    grid.length=0; leaves.clear(); powers.clear();

    for (let r=0;r<ROWS;r++){
      const row=[];
      for (let c=0;c<COLS;c++){
        const ch = currentMap[r][c] || "#";
        const isW = ch==="#";
        row.push(isW?1:0);

        if (ch===".") leaves.add(k(r,c));
        if (ch==="o") powers.add(k(r,c));
        if (ch==="P") playerStart={r,c};
        if (ch==="G") ghostHome={r,c};
      }
      grid.push(row);
    }
  }

  function isWall(r,c){
    if (c<0 || c>=COLS) return false;
    if (r<0 || r>=ROWS) return true;
    return grid[r][c]===1;
  }

  // ===== Entities =====
  const DIRS = {
    up:{dr:-1,dc:0}, down:{dr:1,dc:0}, left:{dr:0,dc:-1}, right:{dr:0,dc:1}, none:{dr:0,dc:0}
  };
  function opposite(d){
    if (d===DIRS.up) return DIRS.down;
    if (d===DIRS.down) return DIRS.up;
    if (d===DIRS.left) return DIRS.right;
    if (d===DIRS.right) return DIRS.left;
    return DIRS.none;
  }
  function canMove(r,c,dir){
    const nr=r+dir.dr;
    let nc=c+dir.dc;
    if (nc<0) nc=COLS-1;
    if (nc>=COLS) nc=0;
    if (nr<0 || nr>=ROWS) return false;
    return !isWall(nr,nc);
  }
  function atCenter(x){ return Math.abs(x - Math.round(x)) < 0.05; }

  let nickName = "Guest";
  let score = 0;
  let lives = 3;

  let running = false;
  let paused = false;
  let lastT = 0;
  let gameTime = 0;

  let powerLeft = 0;
  let invincibleLeft = 0;

  // (3) å€’æ•¸æœŸé–“é–å®šæ›´æ–°
  let inCountdown = false;

  const player = {r:0,c:0,dir:DIRS.left,nextDir:DIRS.left};

  const ghosts = [
    {imgKey:"dad",   r:0,c:0,dir:DIRS.left,  base:"chaser", respawn:0, patrolIndex:0},
    {imgKey:"mom",   r:0,c:0,dir:DIRS.right, base:"ambush", respawn:0, patrolIndex:1},
    {imgKey:"water", r:0,c:0,dir:DIRS.up,    base:"patrol", respawn:0, patrolIndex:2},
    {imgKey:"angry", r:0,c:0,dir:DIRS.down,  base:"random", respawn:0, patrolIndex:3},
  ];
  const patrolCorners = [
    {r:1,c:1},{r:1,c:COLS-2},{r:ROWS-2,c:1},{r:ROWS-2,c:COLS-2}
  ];

  function findOpenNear(r,c){
    const offs=[[0,0],[0,-1],[0,1],[-1,0],[1,0],[0,-2],[0,2],[-2,0],[2,0]];
    for (const [dr,dc] of offs){
      const rr=r+dr, cc=c+dc;
      if (rr>=0 && rr<ROWS && cc>=0 && cc<COLS && !isWall(rr,cc)) return {r:rr,c:cc};
    }
    return {r,c};
  }

  function syncUI(){
    uiName.textContent = nickName;
    uiScore.textContent = score;
  }

  btnApply.addEventListener("click", ()=>{
    ensureAudio();
    const v = (nameInput.value||"").trim();
    nickName = v ? v.slice(0,12) : "Guest";
    syncUI();
    sfxBeep(520,0.04,"sine");
  });

  // ===== Overlays =====
  function openHelp(){ paused = true; helpOverlay.style.display = "flex"; }
  function closeHelp(){ helpOverlay.style.display = "none"; paused = false; }

  btnHelp.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(480,0.03,"sine");
    openHelp();
  });
  helpClose.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(420,0.03,"sine");
    closeHelp();
  });
  helpStart.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(620,0.05,"triangle");
    helpOverlay.style.display = "none";
    paused = false;
    if (!running) startGameFlow();
  });

  function openLB(){ paused = true; renderLB(); lbOverlay.style.display = "flex"; }
  function closeLB(){ lbOverlay.style.display = "none"; paused = false; }
  btnLB.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(520,0.04,"sine");
    openLB();
  });
  lbClose.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(420,0.03,"sine");
    closeLB();
  });

  // ===== AI helpers =====
  function dist2(a,b){ const dr=a.r-b.r, dc=a.c-b.c; return dr*dr+dc*dc; }

  function chooseDirToward(ent, target, avoidOpp=true){
    const r=Math.round(ent.r), c=Math.round(ent.c);
    const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
    if (!opts.length) return ent.dir;
    let best=opts[0], bestS=Infinity;
    for (const d of opts){
      if (avoidOpp && d===opposite(ent.dir) && opts.length>1) continue;
      let nr=r+d.dr, nc=c+d.dc;
      if (nc<0) nc=COLS-1;
      if (nc>=COLS) nc=0;
      const s=dist2({r:nr,c:nc}, target);
      if (s<bestS){bestS=s; best=d;}
    }
    return best;
  }
  function chooseDirAway(ent, target){
    const r=Math.round(ent.r), c=Math.round(ent.c);
    const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
    if (!opts.length) return ent.dir;
    let best=opts[0], bestS=-Infinity;
    for (const d of opts){
      if (d===opposite(ent.dir) && opts.length>1) continue;
      let nr=r+d.dr, nc=c+d.dc;
      if (nc<0) nc=COLS-1;
      if (nc>=COLS) nc=0;
      const s=dist2({r:nr,c:nc}, target);
      if (s>bestS){bestS=s; best=d;}
    }
    return best;
  }
  function getGhostTarget(g){
    const pr=Math.round(player.r), pc=Math.round(player.c);
    if (g.base==="chaser") return {r:pr,c:pc};
    if (g.base==="ambush"){
      const pd=player.dir;
      let tr=pr+pd.dr*4;
      let tc=pc+pd.dc*4;
      tr=clamp(tr,1,ROWS-2);
      if (tc<0) tc=COLS-1;
      if (tc>=COLS) tc=0;
      return {r:tr,c:tc};
    }
    if (g.base==="patrol"){
      const me={r:Math.round(g.r), c:Math.round(g.c)};
      const pHere={r:pr,c:pc};
      if (dist2(me,pHere)<=36) return pHere;
      const corner=patrolCorners[g.patrolIndex];
      if (dist2(me,corner)<=4) g.patrolIndex=(g.patrolIndex+1)%patrolCorners.length;
      return patrolCorners[g.patrolIndex];
    }
    return {r:pr,c:pc};
  }

  function ghostRatioByTime(){
    const t = clamp(gameTime / GHOST_RAMP_SECS, 0, 1);
    return GHOST_MIN_RATIO + (GHOST_MAX_RATIO - GHOST_MIN_RATIO) * t;
  }

  function stepEntity(ent, dt, speed){
    const move = speed * dt;

    if (atCenter(ent.r) && atCenter(ent.c)){
      const r=Math.round(ent.r), c=Math.round(ent.c);

      if (ent===player){
        if (canMove(r,c,player.nextDir)) player.dir = player.nextDir;
        else if (!canMove(r,c,player.dir)) player.dir = DIRS.none;
      }else{
        if (ent.respawn>0){
          ent.dir = chooseDirToward(ent, ghostHome, true);
        }else if (powerLeft>0){
          ent.dir = chooseDirAway(ent, {r:Math.round(player.r), c:Math.round(player.c)});
        }else{
          if (ent.base==="random"){
            const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
            const filtered=opts.filter(d=>d!==opposite(ent.dir));
            const list = filtered.length?filtered:opts;
            if (list.length) ent.dir = list[Math.floor(Math.random()*list.length)];
          }else{
            ent.dir = chooseDirToward(ent, getGhostTarget(ent), true);
          }
        }
      }
    }

    let nr = ent.r + ent.dir.dr*move;
    let nc = ent.c + ent.dir.dc*move;

    if (nc<0) nc=COLS-0.01;
    if (nc>=COLS) nc=0.01;

    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      }else{
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  function tryEat(){
    const r=Math.round(player.r), c=Math.round(player.c);
    const kk=k(r,c);
    if (leaves.has(kk)){
      leaves.delete(kk);
      score += 1;
      uiScore.textContent = score;
      sfxBeep(680,0.03,"sine");
    }else if (powers.has(kk)){
      powers.delete(kk);
      score += 5;
      uiScore.textContent = score;
      powerLeft = POWER_TIME;
      sfxBeep(260,0.08,"square");
    }
  }

  function collide(a,b){
    return Math.abs(a.r-b.r)<0.45 && Math.abs(a.c-b.c)<0.45;
  }

  function respawnPlayer(){
    player.r=playerStart.r;
    player.c=playerStart.c;
    player.dir=DIRS.left;
    player.nextDir=DIRS.left;
    invincibleLeft = INVINCIBLE_TIME;

    const home=findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p=findOpenNear(home.r, home.c + (i%2===0?-1:1));
      g.r=p.r; g.c=p.c;
      g.dir=(i%2===0?DIRS.left:DIRS.right);
      g.respawn=0;
    });
  }

  function onHit(){
    if (invincibleLeft>0) return;
    lives -= 1;
    sfxBeep(140,0.18,"sawtooth");
    if (lives<=0){
      endGame(false);
      return;
    }
    powerLeft = 0;
    respawnPlayer();
  }

  function endGame(win){
    running=false;
    paused=false;
    addLB(nickName, score);
    updateBest();
    openLB();
  }

  // ===== Drawing =====
  function drawMapBackground(){
    ctx.fillStyle = cssVar("--mapBase");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const spot = cssVar("--mapSpot");
    ctx.globalAlpha = 0.18;
    for (let i=0;i<110;i++){
      const x = (i*91)%canvas.width;
      const y = (i*57)%canvas.height;
      const r = 10 + (i*9)%20;
      ctx.fillStyle = spot;
      ctx.beginPath();
      ctx.ellipse(x,y,r*1.2,r*0.75,(i%12)*0.16,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // (2) ç‰†ï¼šåªä¿ç•™æ¢ç´‹ï¼ˆç§»é™¤æ–‘é»ï¼‰
  function drawWallTile(x,y,size,seed){
    const border = cssVar("--wallBorder");
    const base   = cssVar("--wallBase");
    const stripe = cssVar("--wallStripe");

    // shadow
    ctx.globalAlpha = 0.32;
    ctx.fillStyle = "#000";
    roundRect(x+3, y+4, size-6, size-6, 7);
    ctx.fill();
    ctx.globalAlpha = 1;

    // border
    ctx.fillStyle = border;
    roundRect(x+1.5, y+1.5, size-3, size-3, 7);
    ctx.fill();

    // inner base
    ctx.fillStyle = base;
    roundRect(x+4, y+4, size-8, size-8, 6);
    ctx.fill();

    // clip for stripes
    ctx.save();
    roundRect(x+4, y+4, size-8, size-8, 6);
    ctx.clip();

    // diagonal stripes only
    const stripeW = 6;
    ctx.globalAlpha = 0.78;
    ctx.strokeStyle = stripe;
    ctx.lineWidth = stripeW;

    const offset = (seed % 20) - 10;
    for (let i=-40;i<40;i++){
      const x0 = x + i*10 + offset;
      ctx.beginPath();
      ctx.moveTo(x0, y-10);
      ctx.lineTo(x0 + size + 20, y + size + 30);
      ctx.stroke();
    }

    ctx.restore();
    ctx.globalAlpha = 1;

    // highlight
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.2;
    roundRect(x+6, y+6, size-12, size-12, 5.5);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawWalls(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (!isWall(r,c)) continue;
        const seed = (r*131 + c*197)>>>0;
        drawWallTile(c*TILE, r*TILE, TILE, seed);
      }
    }
  }

  function drawLeaf(x,y){
    const a=cssVar("--leaf1");
    const b=cssVar("--leaf2");

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = a;
    ctx.beginPath();
    ctx.arc(x,y,7,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.strokeStyle = b;
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(x-1,y+4);
    ctx.lineTo(x+2,y+7);
    ctx.stroke();

    ctx.fillStyle = a;
    ctx.beginPath();
    ctx.ellipse(x-2,y,4.6,3.0,-0.65,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+2,y+1,4.6,3.0,0.65,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.45;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(x-2,y-0.8,1.8,1.0,-0.65,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawLeaves(){
    leaves.forEach(key=>{
      const [r,c]=key.split(",").map(Number);
      drawLeaf(c*TILE+TILE/2, r*TILE+TILE/2);
    });
  }

  function drawPowerFruit(x,y,t){
    const p1=cssVar("--power1");
    const p2=cssVar("--power2");

    const pulse = 0.5 + 0.5*Math.sin(t*6);
    ctx.globalAlpha = 0.25 + 0.2*pulse;
    ctx.fillStyle = p1;
    ctx.beginPath();
    ctx.arc(x,y, 14+2*pulse, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const g = ctx.createRadialGradient(x-3,y-4,2, x,y,11);
    g.addColorStop(0,"#fff6c9");
    g.addColorStop(0.45,p1);
    g.addColorStop(1,p2);

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(x,y,10,11,0,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.65;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x-12,y); ctx.lineTo(x-7,y);
    ctx.moveTo(x+7,y); ctx.lineTo(x+12,y);
    ctx.moveTo(x,y-12); ctx.lineTo(x,y-7);
    ctx.moveTo(x,y+7); ctx.lineTo(x,y+12);
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.fillStyle = cssVar("--leaf1");
    ctx.beginPath();
    ctx.ellipse(x+5,y-11,4.2,2.4,-0.5,0,Math.PI*2);
    ctx.fill();
  }

  function drawPowers(t){
    powers.forEach(key=>{
      const [r,c]=key.split(",").map(Number);
      drawPowerFruit(c*TILE+TILE/2, r*TILE+TILE/2, t + r*0.2 + c*0.1);
    });
  }

  function drawSprite(img, x, y, size, fallback="#111"){
    if (img){
      ctx.drawImage(img, x-size/2, y-size/2, size, size);
    }else{
      ctx.fillStyle=fallback;
      ctx.beginPath();
      ctx.arc(x,y,size/2,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawPlayerAura(x,y,t){
    if (powerLeft>0){
      const pulse=0.5+0.5*Math.sin(t*9);
      ctx.globalAlpha = 0.35 + 0.25*pulse;
      ctx.fillStyle = cssVar("--power1");
      ctx.beginPath();
      ctx.arc(x,y, 18+3*pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    if (invincibleLeft>0){
      const pulse=0.5+0.5*Math.sin(t*12);
      ctx.globalAlpha = 0.25 + 0.35*pulse;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x,y, 22+4*pulse, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  function drawGhostWeakRing(x,y,t){
    const pulse=0.5+0.5*Math.sin(t*8);
    ctx.globalAlpha = 0.22 + 0.20*pulse;
    ctx.fillStyle = cssVar("--blueWeak");
    ctx.beginPath();
    ctx.arc(x,y, 18+4*pulse, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = "#bfe8ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x,y, 22+4*pulse, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function draw(t){
    drawMapBackground();
    drawWalls();
    drawLeaves();
    drawPowers(t);

    const px = player.c*TILE + TILE/2;
    const py = player.r*TILE + TILE/2;
    drawPlayerAura(px,py,t);
    drawSprite(images.player, px, py, 26, "#333");

    ghosts.forEach(g=>{
      const gx = g.c*TILE + TILE/2;
      const gy = g.r*TILE + TILE/2;

      if (g.respawn>0) ctx.globalAlpha = 0.55;

      if (powerLeft>0 && g.respawn<=0){
        drawGhostWeakRing(gx,gy,t+(g.r+g.c)*0.2);
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(46,168,255,0.20)";
        ctx.beginPath();
        ctx.arc(gx,gy,14,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      drawSprite(images[g.imgKey], gx, gy, 26, "#111");
      ctx.globalAlpha = 1;
    });

    if (powerLeft>0 || invincibleLeft>0){
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(8,8, 210, 28);
      ctx.globalAlpha = 1;
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillStyle = powerLeft>0 ? cssVar("--power1") : "#fff";
      let text = "";
      if (powerLeft>0) text += `å¼·åŒ– ${powerLeft.toFixed(1)}s `;
      if (invincibleLeft>0) text += `ç„¡æ•µ ${invincibleLeft.toFixed(1)}s`;
      ctx.fillText(text.trim(), 14, 27);
    }
  }

  // ===== Countdown (3) =====
  function showCountdown3(){
    return new Promise((resolve)=>{
      inCountdown = true;
      paused = true;
      countdownEl.style.display = "flex";

      const seq = [3,2,1];
      let i = 0;

      const tick = ()=>{
        const n = seq[i];
        cdNumEl.textContent = String(n);
        // å°æç¤ºéŸ³ï¼ˆå¾ˆè¼•ï¼‰
        sfxBeep(520 + (3-n)*80, 0.04, "triangle");

        i++;
        if (i >= seq.length){
          // çµæŸï¼š0.25s å¾Œé–‹å§‹
          setTimeout(()=>{
            countdownEl.style.display = "none";
            paused = false;
            inCountdown = false;
            resolve();
          }, 220);
          return;
        }
        setTimeout(tick, 800);
      };

      tick();
    });
  }

  // ===== Start / Reset =====
  async function resetGame(){
    randomizeMap();
    parseMap();

    score = 0;
    lives = 3;
    powerLeft = 0;
    invincibleLeft = 0;
    gameTime = 0;

    player.r=playerStart.r; player.c=playerStart.c;
    player.dir=DIRS.left; player.nextDir=DIRS.left;

    const home=findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p=findOpenNear(home.r, home.c + (i%2===0?-1:1));
      g.r=p.r; g.c=p.c;
      g.dir=(i%2===0?DIRS.left:DIRS.right);
      g.respawn=0;
      g.patrolIndex=i%patrolCorners.length;
    });

    running = true;
    lastT = performance.now();
    syncUI();

    // (3) å€’æ•¸å¾Œæ‰é–‹å§‹è·‘
    await showCountdown3();
  }

  async function startGameFlow(){
    ensureAudio();
    if (bgmOn) startBgm();
    btnStart.textContent = "é‡æ–°é–‹å§‹";
    await resetGame();
  }

  btnStart.addEventListener("click", async ()=>{
    ensureAudio();
    sfxBeep(660,0.05,"triangle");

    if (!running){
      openHelp();
      return;
    }
    // é¿å…é‡è¤‡é»é€ æˆå¤šå€‹å€’æ•¸åŒæ™‚è·‘
    if (inCountdown) return;

    await resetGame();
  });

  // ===== Intro =====
  function showIntro(){
    running = false;
    paused = true;
    helpOverlay.style.display = "flex";
    btnStart.textContent = "é–‹å§‹";
  }

  // ===== Game loop =====
  function loop(now){
    const t = now/1000;

    // å€’æ•¸/æš«åœï¼šåªç•«ä¸æ›´æ–°
    if (!running){
      draw(t);
      requestAnimationFrame(loop);
      return;
    }

    const dt = Math.min(0.04, (now - lastT)/1000);
    lastT = now;

    if (paused){
      draw(t);
      requestAnimationFrame(loop);
      return;
    }

    gameTime += dt;
    if (powerLeft>0) powerLeft = Math.max(0, powerLeft - dt);
    if (invincibleLeft>0) invincibleLeft = Math.max(0, invincibleLeft - dt);

    stepEntity(player, dt, SPEED_PLAYER);
    tryEat();

    let gRatio = ghostRatioByTime();
    let ghostSpeed = SPEED_PLAYER * gRatio;
    if (powerLeft>0) ghostSpeed *= 0.72;

    ghosts.forEach(g=>{
      if (g.respawn>0) g.respawn = Math.max(0, g.respawn - dt);
      stepEntity(g, dt, ghostSpeed);
    });

    for (const g of ghosts){
      if (!collide(player,g)) continue;

      if (powerLeft>0 && g.respawn<=0){
        score += 10;
        uiScore.textContent = score;
        sfxBeep(900,0.06,"triangle");
        g.respawn = RESPAWN_TIME;
        const home=findOpenNear(ghostHome.r, ghostHome.c);
        g.r=home.r; g.c=home.c;
        g.dir=DIRS.up;
      }else if (g.respawn<=0){
        // hit
        if (invincibleLeft<=0){
          lives -= 1;
          sfxBeep(140,0.18,"sawtooth");
          if (lives<=0){
            endGame(false);
            break;
          }
          powerLeft = 0;
          respawnPlayer();
        }
        break;
      }
    }

    if (leaves.size + powers.size === 0){
      sfxBeep(760,0.10,"sine");
      endGame(true);
    }

    draw(t);
    requestAnimationFrame(loop);
  }

  // ===== Controls =====
  function bindPad(el, dir){
    el.addEventListener("pointerdown", (e)=>{
      e.preventDefault();
      ensureAudio();
      player.nextDir = dir;
      sfxBeep(520,0.02,"sine");
    }, {passive:false});
  }
  bindPad(padLeft, DIRS.left);
  bindPad(padUp, DIRS.up);
  bindPad(padRight, DIRS.right);
  bindPad(padDown, DIRS.down);

  window.addEventListener("keydown", (e)=>{
    ensureAudio();
    const k = e.key.toLowerCase();
    if (k==="arrowup" || k==="w") player.nextDir=DIRS.up;
    if (k==="arrowdown" || k==="s") player.nextDir=DIRS.down;
    if (k==="arrowleft" || k==="a") player.nextDir=DIRS.left;
    if (k==="arrowright" || k==="d") player.nextDir=DIRS.right;
  }, {passive:true});

  // ===== Init =====
  async function init(){
    // å…ˆåˆå§‹åŒ–ä¸€æ¬¡åœ°åœ–ï¼ˆéæ­£å¼é–‹å§‹ï¼‰
    randomizeMap();
    parseMap();

    renderLB();
    updateBest();
    syncUI();

    await preloadImages();

    showIntro();
    requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
