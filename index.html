<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é¹¿é¹¿è¿·å®® GOï¼</title>
  <style>
    :root{
      --bg:#07070a;
      --panel:#0f1020cc;
      --text:#f2f3ff;
      --muted:#a8abff;
      --wall:#2f6bff;
      --dot:#ffd3b6;
      --power:#ffe066;
      --danger:#ff5a7a;
      --ok:#51ffb0;
      --radius:18px;
      --safeB: env(safe-area-inset-bottom);
      --safeT: env(safe-area-inset-top);
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 700px at 50% 20%, #141533, var(--bg)); color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC","PingFang TC","Microsoft JhengHei", Arial, sans-serif;
      overflow:hidden;
    }
    .wrap{
      height:100%;
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
      padding: 12px 12px calc(12px + var(--safeB));
      box-sizing:border-box;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding-top: var(--safeT);
    }
    .card{
      background:var(--panel);
      border:1px solid #ffffff22;
      border-radius: var(--radius);
      padding:10px 12px;
      box-shadow: 0 12px 40px #00000055;
      backdrop-filter: blur(8px);
    }
    .hud{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .hud .pill{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid #ffffff22;
      background:#00000022;
      font-size:14px;
    }
    .hud b{color:#fff}
    .btns{display:flex; gap:8px; flex-wrap:wrap;}
    button{
      border:1px solid #ffffff22;
      background:#14163a;
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    .stage{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }
    canvas{
      width:min(94vw, 920px);
      height:auto;
      max-height: 70vh;
      border-radius: var(--radius);
      border:1px solid #ffffff22;
      background:#000;
      box-shadow: 0 18px 60px #00000088;
      image-rendering: pixelated;
      touch-action:none;
    }
    .bottom{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 680px){
      .grid2{grid-template-columns:1fr}
    }

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .modal{
      pointer-events:auto;
      width:min(92vw, 520px);
      border-radius: 22px;
      border:1px solid #ffffff22;
      background: linear-gradient(180deg,#171a45,#0b0c18);
      box-shadow: 0 20px 80px #000000aa;
      padding:16px;
    }
    .modal h2{margin:4px 0 10px; font-size:20px}
    .modal p{margin:6px 0; color:var(--muted); font-size:14px; line-height:1.5}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px}
    input{
      flex:1;
      min-width: 160px;
      border-radius: 14px;
      border:1px solid #ffffff22;
      background:#00000033;
      color:var(--text);
      padding:12px 12px;
      font-size:16px;
      outline:none;
    }
    .hint{
      font-size:12px;
      color:#cfd1ff;
      opacity:.9;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
      overflow:hidden;
      border-radius: 14px;
    }
    th,td{padding:8px 10px; border-bottom:1px solid #ffffff14}
    th{color:#dfe0ff; text-align:left; background:#00000022}
    td{color:#f3f4ff}
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ffffff22; font-size:12px; color:#dfe0ff;
      background:#00000022;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="card hud" style="flex:1">
      <div class="pill">ç©å®¶ï¼š<b id="nick">-</b></div>
      <div class="pill">åˆ†æ•¸ï¼š<b id="score">0</b></div>
      <div class="pill">ç”Ÿå‘½ï¼š<b id="lives">3</b></div>
      <div class="pill">å‰©é¤˜é»é»ï¼š<b id="remain">0</b></div>
      <div class="pill">ç‹€æ…‹ï¼š<b id="state" style="color:var(--ok)">ä¸€èˆ¬</b></div>
    </div>
    <div class="card btns">
      <button id="btnRestart">é‡æ–°é–‹å§‹</button>
      <button id="btnSound">ğŸ”Š è²éŸ³ï¼šé–‹</button>
    </div>
  </div>

  <div class="stage">
    <canvas id="game" width="840" height="510"></canvas>

    <div class="overlay" id="overlay">
      <div class="modal" id="modal">
        <h2 id="modalTitle">é¹¿é¹¿è¿·å®® GOï¼</h2>
        <p id="modalText">é–‹å±€å‰å…ˆå–å€‹æš±ç¨±å§ï½ï¼ˆæ’è¡Œæ¦œä¿ç•™ 7 å¤©ï¼Œåªé¡¯ç¤ºå‰ 6 åï¼‰</p>
        <div class="row">
          <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆæœ€å¤š12å­—ï¼‰" />
          <button id="btnStart">é–‹å§‹éŠæˆ²</button>
        </div>
        <p class="hint">æ“ä½œï¼šéµç›¤æ–¹å‘éµï¼WASDã€‚æ‰‹æ©Ÿï¼šåœ¨ç•«é¢ä¸Šæ»‘å‹•ã€‚<br/>åƒå°é» +1ï¼›åƒå¤§é»é€²å…¥å¼·åŒ–æ¨¡å¼å¯ååƒæ•µäººã€‚</p>

        <div style="margin-top:12px">
          <div class="row" style="justify-content:space-between; margin:0 0 8px">
            <span class="tag">ğŸ† å‰ 6 åï¼ˆ7 å¤©å…§ï¼‰</span>
            <span class="hint" id="lbHint"></span>
          </div>
          <table>
            <thead><tr><th>#</th><th>æš±ç¨±</th><th>åˆ†æ•¸</th><th>æ—¥æœŸ</th></tr></thead>
            <tbody id="lbBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div class="bottom">
    <div class="card">
      <div class="grid2">
        <div>
          <b>è§’è‰²</b>
          <p style="margin:6px 0 0; color:var(--muted); font-size:14px; line-height:1.5">
            é¹¿é¹¿ï¼ˆä½ ï¼‰åƒæ‰è¿·å®®è£¡çš„å«©è‘‰é»é»ã€‚åƒåˆ°èƒ½é‡æœæœƒé€²å…¥å¼·åŒ–æ¨¡å¼ï¼ŒçŸ­æ™‚é–“å…§å¯ä»¥ååƒæ•µäººåŠ åˆ†ã€‚
          </p>
        </div>
        <div>
          <b>æ•µäºº AI</b>
          <p style="margin:6px 0 0; color:var(--muted); font-size:14px; line-height:1.5">
            é¹¿çˆ¸ï¼šè¿½æ“Šä½ ï¼›èŠ±åª½ï¼šé åˆ¤è·¯ç·šï¼›é˜¿æ°´ï¼šå·¡é‚/åˆ‡æ›è¿½æ“Šï¼›ç”Ÿæ°£é¹¿é¹¿ï¼šè·¯å£éš¨æ©Ÿã€‚
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== ä½ æä¾›çš„åœ–æª” ======
  const IMG = {
    player: "https://github.com/z883662/Aruru/blob/main/lulu1.png?raw=true",
    dad:    "https://github.com/z883662/Aruru/blob/main/lulu2.png?raw=true",
    mom:    "https://github.com/z883662/Aruru/blob/main/lulu3.png?raw=true",
    water:  "https://github.com/z883662/Aruru/blob/main/lulu4.png?raw=true",
    angry:  "https://github.com/z883662/Aruru/blob/main/lulu5.png?raw=true",
  };

  // ====== è¿·å®®è—åœ–ï¼ˆ28x17ï¼‰ ======
  const MAP = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "######.##          ##.######",
    "#..........###G###..........#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "#......##....P.....##......#",
    "############################",
  ];

  // åœ°åœ–è§£æï¼šç‰†(#)ã€å°é»(.)ã€å¤§é»(o)ã€ç©º( )ã€ç©å®¶(P)ã€æ•µäºº(G)
  // æ³¨æ„ï¼šä¸­é–“å…©è¡Œæœ‰ç©ºæ ¼ï¼Œä»£è¡¨å·¦å³é€šé“/æˆ¿é–“å€åŸŸ

  // ====== Canvas ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // ====== UI ======
  const elNick   = document.getElementById("nick");
  const elScore  = document.getElementById("score");
  const elLives  = document.getElementById("lives");
  const elRemain = document.getElementById("remain");
  const elState  = document.getElementById("state");

  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalText  = document.getElementById("modalText");
  const nameInput  = document.getElementById("nameInput");
  const btnStart   = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");
  const btnSound   = document.getElementById("btnSound");

  const lbBody = document.getElementById("lbBody");
  const lbHint = document.getElementById("lbHint");

  // ====== éŸ³æ•ˆï¼ˆiOS/LINEï¼šé¦–æ¬¡äº’å‹•è§£é–ï¼‰ ======
  let audioEnabled = true;
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudioUnlocked(){
    if (!audioEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioUnlocked = true;
  }
  function beep(freq=520, dur=0.05, type="sine", gain=0.03){
    if (!audioEnabled || !audioUnlocked) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  // ====== æ’è¡Œæ¦œï¼ˆLocalStorageï¼Œå‰6åï¼Œä¿ç•™7å¤©ï¼‰ ======
  const LB_KEY = "lulu_pacman_lb_v1";
  const KEEP_MS = 7 * 24 * 60 * 60 * 1000;

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      const now = Date.now();
      return arr.filter(x => x && typeof x.score==="number" && typeof x.name==="string" && typeof x.ts==="number" && (now - x.ts) <= KEEP_MS);
    }catch(e){ return []; }
  }
  function saveLB(arr){
    try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch(e){}
  }
  function updateLB(name, score){
    const now = Date.now();
    let lb = loadLB();
    lb.push({name, score, ts: now});
    lb.sort((a,b)=> b.score - a.score || b.ts - a.ts);
    lb = lb.slice(0,6);
    saveLB(lb);
    renderLB();
  }
  function fmtDate(ts){
    const d = new Date(ts);
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  function renderLB(){
    const lb = loadLB();
    lbBody.innerHTML = lb.map((r,i)=>(
      `<tr><td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${r.score}</td><td>${fmtDate(r.ts)}</td></tr>`
    )).join("") || `<tr><td colspan="4" style="color:#a8abff">ç›®å‰æ²’æœ‰ç´€éŒ„</td></tr>`;
    lbHint.textContent = lb.length ? "ï¼ˆè‡ªå‹•æ¸…é™¤è¶…é 7 å¤©ç´€éŒ„ï¼‰" : "ï¼ˆä½ æœƒæ˜¯ç¬¬ä¸€åï¼‰";
  }
  function escapeHtml(s){
    return (s+"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // ====== éŠæˆ²åƒæ•¸ ======
  const TILE = 30;                     // 30px per tile
  const ROWS = MAP.length;
  const COLS = MAP[0].length;          // 28

  // è®“ canvas å…§è§£æåº¦é…åˆ tile
  canvas.width  = COLS * TILE;
  canvas.height = ROWS * TILE;

  const SPEED_PLAYER = 5.2;            // tiles per second (converted later)
  const SPEED_GHOST  = 4.8;
  const SPEED_FRIGHT = 3.2;

  const POWER_TIME = 7.0;              // seconds
  const RESPAWN_TIME = 1.6;

  // ====== åœ°åœ–è³‡æ–™ ======
  const grid = [];   // walls
  const dots = new Set(); // "." positions key "r,c"
  const powers = new Set(); // "o"
  let playerStart = {r:0,c:0};
  let ghostHome = {r:0,c:0};

  function key(r,c){ return r + "," + c; }

  function parseMap(){
    grid.length = 0;
    dots.clear(); powers.clear();
    for (let r=0; r<ROWS; r++){
      const row = [];
      const line = MAP[r];
      for (let c=0; c<COLS; c++){
        const ch = line[c] || " ";
        const isWall = (ch === "#");
        row.push(isWall ? 1 : 0);
        if (ch === ".") dots.add(key(r,c));
        if (ch === "o") powers.add(key(r,c));
        if (ch === "P") playerStart = {r,c};
        if (ch === "G") ghostHome = {r,c};
      }
      grid.push(row);
    }
  }

  function isWall(r,c){
    // å·¦å³å‚³é€ï¼šè¶…å‡ºè¦–ç‚ºç©¿è¶Š
    if (c < 0 || c >= COLS) return false;
    if (r < 0 || r >= ROWS) return true;
    return grid[r][c] === 1;
  }

  function wrapPos(pos){
    if (pos.c < 0) pos.c = COLS-1;
    if (pos.c >= COLS) pos.c = 0;
  }

  // ====== åœ–ç‰‡è¼‰å…¥ ======
  const images = {};
  function loadImage(src){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.onload = ()=>resolve(im);
      im.onerror = reject;
      im.src = src;
    });
  }

  // ====== å¯¦é«” ======
  const DIRS = {
    up:    {dr:-1, dc: 0},
    down:  {dr: 1, dc: 0},
    left:  {dr: 0, dc:-1},
    right: {dr: 0, dc: 1},
    none:  {dr: 0, dc: 0},
  };
  function opposite(d){
    if (d===DIRS.up) return DIRS.down;
    if (d===DIRS.down) return DIRS.up;
    if (d===DIRS.left) return DIRS.right;
    if (d===DIRS.right) return DIRS.left;
    return DIRS.none;
  }

  function canMove(r,c,dir){
    const nr = r + dir.dr;
    let nc = c + dir.dc;
    if (nc < 0) nc = COLS-1;
    if (nc >= COLS) nc = 0;
    if (nr < 0 || nr >= ROWS) return false;
    return !isWall(nr,nc);
  }

  function atCenter(x){ return Math.abs(x - Math.round(x)) < 0.05; }

  // ====== éŠæˆ²ç‹€æ…‹ ======
  let nickName = "-";
  let score = 0;
  let lives = 3;
  let powerLeft = 0;          // seconds
  let running = false;
  let lastTime = 0;

  const player = {
    r:0, c:0, dir:DIRS.left, nextDir:DIRS.left,
    speed: SPEED_PLAYER,
    alive:true
  };

  const ghosts = [
    { name:"é¹¿çˆ¸",   imgKey:"dad",   r:0, c:0, dir:DIRS.left,  mode:"chase",  base:"chaser",   respawn:0 },
    { name:"èŠ±åª½",   imgKey:"mom",   r:0, c:0, dir:DIRS.right, mode:"chase",  base:"ambush",   respawn:0 },
    { name:"é˜¿æ°´",   imgKey:"water", r:0, c:0, dir:DIRS.up,    mode:"chase",  base:"patrol",   respawn:0 },
    { name:"ç”Ÿæ°£é¹¿é¹¿", imgKey:"angry", r:0, c:0, dir:DIRS.down, mode:"chase", base:"random",   respawn:0 },
  ];
  const patrolCorners = [
    {r:1, c:1},
    {r:1, c:COLS-2},
    {r:ROWS-2, c:1},
    {r:ROWS-2, c:COLS-2},
  ];

  function resetGame(){
    parseMap();
    score = 0;
    lives = 3;
    powerLeft = 0;
    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;
    player.alive = true;

    // ghosts start around home
    ghosts.forEach((g,i)=>{
      g.r = ghostHome.r;
      g.c = ghostHome.c + (i%2===0 ? -1 : 1);
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.mode = "chase";
      g.respawn = 0;
      g.patrolIndex = i % patrolCorners.length;
    });

    running = true;
    lastTime = performance.now();
    syncHUD();
  }

  function syncHUD(){
    elNick.textContent = nickName;
    elScore.textContent = score;
    elLives.textContent = lives;
    elRemain.textContent = dots.size + powers.size;
    if (powerLeft > 0){
      elState.textContent = "å¼·åŒ–";
      elState.style.color = "var(--power)";
    }else{
      elState.textContent = "ä¸€èˆ¬";
      elState.style.color = "var(--ok)";
    }
  }

  // ====== ç›®æ¨™é¸æ“‡ï¼ˆé¬¼ AIï¼‰ ======
  function dist2(a,b){
    const dr = a.r - b.r, dc = a.c - b.c;
    return dr*dr + dc*dc;
  }

  function chooseDirToward(entity, target, avoidOpposite=true){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);

    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0];
    let bestScore = Infinity;

    for (const d of options){
      if (avoidOpposite && d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s < bestScore){
        bestScore = s;
        best = d;
      }
    }
    return best;
  }

  function chooseDirAway(entity, target){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);

    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0];
    let bestScore = -Infinity;

    for (const d of options){
      if (d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s > bestScore){
        bestScore = s;
        best = d;
      }
    }
    return best;
  }

  function getGhostTarget(g){
    const pr = Math.round(player.r);
    const pc = Math.round(player.c);

    if (g.base === "chaser"){
      return {r: pr, c: pc};
    }

    if (g.base === "ambush"){
      // ç›®æ¨™ = ç©å®¶å‰æ–¹ 4 æ ¼
      const pd = player.dir;
      let tr = pr + pd.dr * 4;
      let tc = pc + pd.dc * 4;
      // clamp within map rows, wrap cols
      tr = Math.max(1, Math.min(ROWS-2, tr));
      if (tc < 0) tc = COLS-1;
      if (tc >= COLS) tc = 0;
      return {r: tr, c: tc};
    }

    if (g.base === "patrol"){
      // å¹³å¸¸å·¡é‚è§’è½ï¼Œæ¥è¿‘ç©å®¶å°±è¿½
      const me = {r: Math.round(g.r), c: Math.round(g.c)};
      const playerHere = {r: pr, c: pc};
      if (dist2(me, playerHere) <= 36){ // within ~6 tiles
        return playerHere;
      }
      const corner = patrolCorners[g.patrolIndex];
      if (dist2(me, corner) <= 4){
        g.patrolIndex = (g.patrolIndex + 1) % patrolCorners.length;
      }
      return patrolCorners[g.patrolIndex];
    }

    // random
    return {r: pr, c: pc};
  }

  // ====== ç§»å‹•æ›´æ–° ======
  function stepEntity(ent, dt, speed){
    // dt seconds, speed tiles/sec
    const move = speed * dt;

    // åœ¨æ ¼å­ä¸­å¿ƒæ‰å…è¨±è½‰å‘
    if (atCenter(ent.r) && atCenter(ent.c)){
      const r = Math.round(ent.r);
      const c = Math.round(ent.c);

      // ç©å®¶ç”¨ nextDir
      if (ent === player){
        if (canMove(r,c,ent.nextDir)) ent.dir = ent.nextDir;
        else if (!canMove(r,c,ent.dir)) ent.dir = DIRS.none;
      }

      // èµ°åˆ°è·¯å£ï¼Œå°é¬¼åšæ±ºç­–
      if (ent !== player){
        if (ent.respawn > 0){
          // respawnï¼šç›´æ¥å¾€å®¶èµ°
          ent.dir = chooseDirToward(ent, ghostHome, true);
        } else if (powerLeft > 0){
          // frightenedï¼šé é›¢ç©å®¶
          ent.dir = chooseDirAway(ent, {r: Math.round(player.r), c: Math.round(player.c)});
        } else {
          if (ent.base === "random"){
            // éš¨æ©Ÿä½†ä¸ç«‹åˆ»å›é ­
            const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
            const filtered = options.filter(d => d !== opposite(ent.dir));
            const list = (filtered.length ? filtered : options);
            if (list.length){
              ent.dir = list[Math.floor(Math.random()*list.length)];
            }
          } else {
            const target = getGhostTarget(ent);
            ent.dir = chooseDirToward(ent, target, true);
          }
        }
      }
    }

    // å¯¦éš›ä½ç§»
    let nr = ent.r + ent.dir.dr * move;
    let nc = ent.c + ent.dir.dc * move;

    // Wrap tunnel
    if (nc < 0) nc = COLS - 0.01;
    if (nc >= COLS) nc = 0.01;

    // ç¢°ç‰†è™•ç†ï¼šå¦‚æœä¸‹ä¸€æ ¼æ˜¯ç‰†ï¼Œå¡å›ä¸­å¿ƒ
    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      } else {
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  // ====== éŠæˆ²é‚è¼¯ ======
  function tryEat(){
    const r = Math.round(player.r);
    const c = Math.round(player.c);
    const k = key(r,c);

    if (dots.has(k)){
      dots.delete(k);
      score += 1;
      beep(620, 0.04, "sine", 0.025);
      syncHUD();
    } else if (powers.has(k)){
      powers.delete(k);
      score += 5;
      powerLeft = POWER_TIME;
      beep(220, 0.08, "square", 0.03);
      syncHUD();
    }
  }

  function collide(a,b){
    return Math.abs(a.r - b.r) < 0.45 && Math.abs(a.c - b.c) < 0.45;
  }

  function onPlayerHit(){
    lives -= 1;
    beep(140, 0.20, "sawtooth", 0.02);
    if (lives <= 0){
      gameOver();
      return;
    }
    // reset positions only
    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    ghosts.forEach((g,i)=>{
      g.r = ghostHome.r;
      g.c = ghostHome.c + (i%2===0 ? -1 : 1);
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
    });
    powerLeft = 0;
    syncHUD();
  }

  function gameOver(){
    running = false;
    syncHUD();
    updateLB(nickName, score);

    modalTitle.textContent = "éŠæˆ²çµæŸï¼";
    modalText.textContent = `ä½ çš„åˆ†æ•¸ï¼š${score}ã€‚è¦ä¸è¦å†ä¾†ä¸€å±€ï¼Ÿ`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  function win(){
    running = false;
    updateLB(nickName, score);
    modalTitle.textContent = "é€šé—œæˆåŠŸï¼";
    modalText.textContent = `ä½ æŠŠå«©è‘‰éƒ½åƒå…‰å•¦ï¼åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  // ====== ç¹ªåœ– ======
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // èƒŒæ™¯
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // ç‰†
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--wall").trim() || "#2f6bff";
    ctx.lineWidth = 4;
    ctx.lineJoin = "round";
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        if (isWall(r,c)){
          const x = c*TILE, y = r*TILE;
          ctx.strokeRect(x+3, y+3, TILE-6, TILE-6);
        }
      }
    }

    // é»é»
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--dot").trim() || "#ffd3b6";
    dots.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      ctx.beginPath();
      ctx.arc(x,y,3.2,0,Math.PI*2);
      ctx.fill();
    });

    // èƒ½é‡æœ
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--power").trim() || "#ffe066";
    powers.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      ctx.beginPath();
      ctx.arc(x,y,7.2,0,Math.PI*2);
      ctx.fill();
    });

    // ä¸­å¤®å±‹å­æç¤ºç·šï¼ˆè£é£¾ï¼‰
    const hx = ghostHome.c * TILE;
    const hy = ghostHome.r * TILE;
    ctx.strokeStyle = "#ffffff22";
    ctx.lineWidth = 2;
    ctx.strokeRect(hx - TILE*2, hy - TILE*1, TILE*5, TILE*3);

    // è§’è‰²ï¼šç”¨åœ–ç‰‡ç¹ªåˆ¶
    drawSprite(images.player, player.c*TILE + TILE/2, player.r*TILE + TILE/2, 24);

    ghosts.forEach(g=>{
      if (g.respawn > 0){
        // è®Šæ·¡è¡¨ç¤ºå›å®¶ä¸­
        ctx.globalAlpha = 0.55;
      } else if (powerLeft > 0){
        // frightenedï¼šåŠ è—è‰²é®ç½©
        ctx.globalAlpha = 1.0;
      }
      drawSprite(images[g.imgKey], g.c*TILE + TILE/2, g.r*TILE + TILE/2, 24);

      if (powerLeft > 0 && g.respawn <= 0){
        // frightened ç°¡å–®è—ç½©
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "#3aa0ff";
        ctx.beginPath();
        ctx.arc(g.c*TILE + TILE/2, g.r*TILE + TILE/2, 14, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    });

    // ç‹€æ…‹æ–‡å­—
    if (!running){
      ctx.fillStyle = "#ffffffaa";
      ctx.font = "bold 22px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText("é»æ“Šã€Œé–‹å§‹éŠæˆ²ã€", canvas.width/2, canvas.height/2);
    }

    // å¼·åŒ–å€’æ•¸
    if (powerLeft > 0){
      ctx.fillStyle = "#ffe066";
      ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "left";
      ctx.fillText("å¼·åŒ–ï¼š" + powerLeft.toFixed(1) + "s", 10, 22);
    }
  }

  function drawSprite(img, x, y, size){
    if (!img) return;
    ctx.drawImage(img, x - size/2, y - size/2, size, size);
  }

  // ====== ä¸»è¿´åœˆ ======
  function loop(t){
    if (!running){
      draw();
      requestAnimationFrame(loop);
      return;
    }
    const dt = Math.min(0.04, (t - lastTime) / 1000);
    lastTime = t;

    // power time
    if (powerLeft > 0){
      powerLeft = Math.max(0, powerLeft - dt);
    }

    // move player
    stepEntity(player, dt, player.speed);

    // eat
    tryEat();

    // move ghosts
    ghosts.forEach(g=>{
      if (g.respawn > 0){
        g.respawn = Math.max(0, g.respawn - dt);
      }
      const spd = (powerLeft > 0 && g.respawn<=0) ? SPEED_FRIGHT : SPEED_GHOST;
      stepEntity(g, dt, spd);
    });

    // collisions
    for (const g of ghosts){
      if (collide(player,g)){
        if (powerLeft > 0 && g.respawn<=0){
          // eat ghost
          score += 10;
          beep(820, 0.06, "triangle", 0.03);
          g.respawn = RESPAWN_TIME;
          g.r = ghostHome.r;
          g.c = ghostHome.c;
          g.dir = DIRS.up;
          syncHUD();
        } else if (g.respawn<=0){
          onPlayerHit();
          break;
        }
      }
    }

    // win condition
    if (dots.size + powers.size === 0){
      win();
    }

    syncHUD();
    draw();
    requestAnimationFrame(loop);
  }

  // ====== è¼¸å…¥ï¼šéµç›¤ ======
  window.addEventListener("keydown", (e)=>{
    ensureAudioUnlocked();
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") player.nextDir = DIRS.up;
    if (k === "arrowdown" || k === "s") player.nextDir = DIRS.down;
    if (k === "arrowleft" || k === "a") player.nextDir = DIRS.left;
    if (k === "arrowright" || k === "d") player.nextDir = DIRS.right;
  }, {passive:true});

  // ====== è¼¸å…¥ï¼šæ‰‹æ©Ÿæ»‘å‹• ======
  let touchStart = null;
  canvas.addEventListener("pointerdown", (e)=>{
    ensureAudioUnlocked();
    touchStart = {x:e.clientX, y:e.clientY};
  });
  canvas.addEventListener("pointerup", (e)=>{
    if (!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    touchStart = null;
    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;

    if (Math.abs(dx) > Math.abs(dy)){
      player.nextDir = dx > 0 ? DIRS.right : DIRS.left;
    } else {
      player.nextDir = dy > 0 ? DIRS.down : DIRS.up;
    }
  });

  // ====== UI actions ======
  btnSound.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    audioEnabled = !audioEnabled;
    btnSound.textContent = audioEnabled ? "ğŸ”Š è²éŸ³ï¼šé–‹" : "ğŸ”‡ è²éŸ³ï¼šé—œ";
    if (audioEnabled) beep(520, 0.05, "sine", 0.02);
  });

  btnRestart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    resetGame();
  });

  btnStart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    let name = (nameInput.value || "").trim();
    if (!name) name = "é¹¿ç²‰";
    nickName = name.slice(0,12);
    overlay.style.display = "none";
    btnStart.textContent = "é–‹å§‹éŠæˆ²";
    resetGame();
  });

  // é¦–æ¬¡é»æ“Š anywhere è§£é–è²éŸ³ï¼ˆLINE/iOSï¼‰
  window.addEventListener("pointerdown", ensureAudioUnlocked, {once:false, passive:true});

  // ====== init ======
  async function init(){
    renderLB();
    parseMap();
    syncHUD();

    // load images
    const entries = [
      ["player", IMG.player],
      ["dad",    IMG.dad],
      ["mom",    IMG.mom],
      ["water",  IMG.water],
      ["angry",  IMG.angry],
    ];

    for (const [k,src] of entries){
      try{ images[k] = await loadImage(src); }
      catch(e){ images[k] = null; console.warn("image failed", k, e); }
    }

    overlay.style.display = "flex";
    running = false;
    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>
