<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é¹¿é¹¿è¿·å®® GOï¼</title>

  <style>
    :root{
      --bg:#07070a;
      --panel:#0f1020cc;
      --text:#f2f3ff;
      --muted:#a8abff;
      --wall:#2f6bff;
      --dot:#ffd3b6;
      --power:#ffe066;
      --ok:#51ffb0;

      --radius:18px;
      --safeB: env(safe-area-inset-bottom);
      --safeT: env(safe-area-inset-top);

      /* æ‰‹æ©Ÿ UI å°ºå¯¸ */
      --hudH: 54px;
      --barH: 54px;
      --dpadH: 150px;
      --gap: 10px;
    }

    html,body{
      height:100%;
      margin:0;
      background:radial-gradient(1200px 700px at 50% 20%, #141533, var(--bg));
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC","PingFang TC","Microsoft JhengHei", Arial, sans-serif;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{
      height:100%;
      display:grid;
      grid-template-rows: auto 1fr auto auto;
      gap: var(--gap);
      padding: 10px 10px calc(10px + var(--safeB));
      box-sizing:border-box;
    }

    .card{
      background:var(--panel);
      border:1px solid #ffffff22;
      border-radius: var(--radius);
      box-shadow: 0 12px 40px #00000055;
      backdrop-filter: blur(8px);
    }

    /* ===== HUDï¼šæ‰‹æ©Ÿå–®è¡Œ ===== */
    .hud{
      height: calc(var(--hudH) + var(--safeT));
      padding: calc(8px + var(--safeT)) 10px 8px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      overflow:hidden;
    }
    .hud .left{
      display:flex; gap:8px; align-items:center;
      min-width:0;
      flex:1;
      overflow:hidden;
    }
    .hud .pill{
      border:1px solid #ffffff22;
      background:#00000022;
      padding:6px 8px;
      border-radius:999px;
      font-size:12px;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .hud .pill b{color:#fff}
    .hud .name{
      max-width: 34vw;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .hud .right{
      display:flex; gap:8px; align-items:center;
      flex:0 0 auto;
    }

    /* ===== éŠæˆ²å€ ===== */
    .stage{
      position:relative;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    canvas{
      width:min(96vw, 980px);
      height:auto;
      max-height: calc(100vh - (var(--hudH) + var(--barH) + var(--dpadH) + (var(--gap) * 6) + var(--safeT) + var(--safeB)));
      border-radius: var(--radius);
      border:1px solid #ffffff22;
      background:#000;
      box-shadow: 0 18px 60px #00000088;
      image-rendering: pixelated;
      touch-action:none;
    }

    /* ===== åº•éƒ¨å·¥å…·åˆ—ï¼ˆé‡æ–°é–‹å§‹/è²éŸ³/ç©æ³•ï¼‰ ===== */
    .bar{
      height: var(--barH);
      padding: 8px 10px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .bar .btns{
      display:flex; gap:8px; align-items:center;
      width:100%;
      justify-content:space-between;
    }
    button{
      border:1px solid #ffffff22;
      background:#14163a;
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
    }
    button:active{transform:translateY(1px)}
    button[disabled]{opacity:.55; cursor:not-allowed}

    /* ===== D-Padï¼ˆå¦‚ä½ åœ–ï¼‰ ===== */
    .dpad{
      padding: 8px 10px;
      box-sizing:border-box;
      height: var(--dpadH);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .dpadWrap{
      width: min(720px, 96vw);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 60px 60px;
      gap: 12px;
    }
    .padBtn{
      border-radius: 18px;
      border:1px solid #ffffff22;
      background:#ffffff14;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      touch-action: manipulation;
      font-weight:900;
      font-size:18px;
    }
    .padBtn:active{filter:brightness(1.1); transform:translateY(1px)}
    .padIcon{
      width:26px; height:26px;
      display:flex; align-items:center; justify-content:center;
      border-radius:6px;
      background:#0b67ff;
      border:2px solid #00000055;
      color:#fff;
      font-size:16px;
      line-height:1;
    }
    .padLeft { grid-column:1; grid-row:1; }
    .padUp   { grid-column:2; grid-row:1; }
    .padRight{ grid-column:3; grid-row:1; }
    .padDown { grid-column:2; grid-row:2; }

    /* ===== Overlay / Modal ===== */
    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background:#00000066;
      padding:16px;
    }
    .modal{
      width:min(92vw, 520px);
      border-radius: 22px;
      border:1px solid #ffffff22;
      background: linear-gradient(180deg,#171a45,#0b0c18);
      box-shadow: 0 20px 80px #000000aa;
      padding:16px;
      pointer-events:auto;
    }
    .modal h2{margin:2px 0 10px; font-size:18px}
    .modal p{margin:6px 0; color:var(--muted); font-size:13px; line-height:1.45}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px}
    input{
      flex:1;
      min-width: 160px;
      border-radius: 14px;
      border:1px solid #ffffff22;
      background:#00000033;
      color:var(--text);
      padding:12px 12px;
      font-size:15px;
      outline:none;
    }
    .hint{font-size:12px; color:#cfd1ff; opacity:.9}
    .loadBarOuter{
      height:10px;
      background:#00000033;
      border:1px solid #ffffff22;
      border-radius:999px;
      overflow:hidden;
    }
    .loadBarInner{
      height:100%;
      width:0%;
      background:#51ffb0;
    }

    /* æ’è¡Œæ¦œè¡¨æ ¼ï¼ˆå¯æ²å‹•ï¼‰ */
    .lbBox{
      margin-top:10px;
      border:1px solid #ffffff14;
      border-radius: 14px;
      overflow:hidden;
      max-height: 220px;
      overflow:auto;
      background:#00000022;
    }
    table{width:100%; border-collapse:collapse; font-size:13px}
    th,td{padding:8px 10px; border-bottom:1px solid #ffffff14}
    th{color:#dfe0ff; text-align:left; background:#00000022}
    td{color:#f3f4ff}
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #ffffff22; font-size:12px; color:#dfe0ff;
      background:#00000022;
    }

    /* ===== ç©æ³•è¦–çª—ï¼ˆå¯éš¨æ™‚é–‹é—œï¼‰ ===== */
    .helpModal{
      position:absolute;
      inset:auto 10px calc(var(--dpadH) + var(--barH) + 30px + var(--safeB)) 10px;
      max-width: 520px;
      margin: 0 auto;
      display:none;
      padding:12px 12px;
    }
    .helpModal h3{margin:0 0 8px; font-size:16px}
    .helpModal .line{margin:6px 0; font-size:13px; color:var(--muted); line-height:1.4}
    .helpModal .line b{color:#fff}

    /* å°è¢å¹•å†ç¸® */
    @media (max-width: 420px){
      :root{ --dpadH: 140px; }
      button{ padding:10px 10px; font-size:12px; }
      .hud .pill{ font-size:11px; padding:6px 7px; }
      .padBtn{ border-radius:16px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- HUD -->
    <div class="card hud">
      <div class="left">
        <div class="pill name">ğŸ¦Œ <b id="nick">-</b></div>
        <div class="pill">â­ <b id="score">0</b></div>
        <div class="pill">â¤ï¸ <b id="lives">3</b></div>
        <div class="pill">ğŸƒ <b id="remain">0</b></div>
        <div class="pill">âš¡ <b id="state" style="color:var(--ok)">ä¸€èˆ¬</b></div>
      </div>
      <div class="right">
        <span class="tag">æ‰‹æ©Ÿæ–¹å‘éµæ“æ§</span>
      </div>
    </div>

    <!-- Game -->
    <div class="stage">
      <canvas id="game" width="840" height="510"></canvas>

      <!-- Help floating card -->
      <div class="card helpModal" id="helpCard">
        <h3>ç©æ³•</h3>
        <div class="line">ğŸ¦Œ <b>æ“ä½œï¼š</b>é»æ–¹å‘éµç§»å‹•</div>
        <div class="line">ğŸƒ <b>å¾—åˆ†ï¼š</b>å«©è‘‰ +1ï½œèƒ½é‡æœ +5</div>
        <div class="line">âš¡ <b>å¼·åŒ–ï¼š</b>å¯ååƒæ•µäºº +10</div>
        <div class="line">ğŸ’¥ <b>å¤±æ•—ï¼š</b>ç¢°åˆ°æ•µäºº -1 ç”Ÿå‘½</div>
      </div>

      <!-- Start Modal -->
      <div class="overlay" id="overlay">
        <div class="modal" id="modal">
          <h2 id="modalTitle">é¹¿é¹¿è¿·å®® GOï¼</h2>
          <p id="modalText">è¼¸å…¥æš±ç¨±å¾Œé–‹å§‹ï¼ˆæ’è¡Œæ¦œä¿ç•™ 7 å¤©ï¼Œåªé¡¯ç¤ºå‰ 6 åï¼‰ã€‚</p>

          <div class="row">
            <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆæœ€å¤š12å­—ï¼‰" />
            <button id="btnStart">é–‹å§‹éŠæˆ²</button>
          </div>

          <div style="margin-top:10px">
            <div class="hint" id="loadText">è¼‰å…¥åœ–æª”ä¸­â€¦</div>
            <div class="loadBarOuter">
              <div id="loadBar" class="loadBarInner"></div>
            </div>
          </div>

          <p class="hint" style="margin-top:10px">
            ğŸ“Œ æé†’ï¼šLINE/iOS éœ€é¦–æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚<br/>
            æ“ä½œï¼šæ‰‹æ©Ÿé»æ–¹å‘éµï¼›æ¡Œæ©Ÿå¯ç”¨æ–¹å‘éµ/WASDã€‚
          </p>

          <div style="margin-top:12px; display:flex; justify-content:space-between; align-items:center; gap:10px">
            <span class="tag">ğŸ† å‰ 6 åï¼ˆ7 å¤©å…§ï¼‰</span>
            <span class="hint" id="lbHint"></span>
          </div>
          <div class="lbBox">
            <table>
              <thead><tr><th>#</th><th>æš±ç¨±</th><th>åˆ†æ•¸</th><th>æ—¥æœŸ</th></tr></thead>
              <tbody id="lbBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Bottom Bar -->
    <div class="card bar">
      <div class="btns">
        <button id="btnRestart">ğŸ”„ é‡æ–°é–‹å§‹</button>
        <button id="btnSound">ğŸ”Š è²éŸ³ï¼šé–‹</button>
        <button id="btnHelp">â“ ç©æ³•</button>
      </div>
    </div>

    <!-- D-Pad -->
    <div class="card dpad">
      <div class="dpadWrap">
        <div class="padBtn padLeft"  id="padLeft"><div class="padIcon">â†</div></div>
        <div class="padBtn padUp"    id="padUp"><div class="padIcon">â†‘</div></div>
        <div class="padBtn padRight" id="padRight"><div class="padIcon">â†’</div></div>
        <div class="padBtn padDown"  id="padDown"><div class="padIcon">â†“</div></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== ä½ æä¾›çš„åœ–æª” ======
  const IMG = {
    player: "https://github.com/z883662/Aruru/blob/main/lulu1.png?raw=true",
    dad:    "https://github.com/z883662/Aruru/blob/main/lulu2.png?raw=true",
    mom:    "https://github.com/z883662/Aruru/blob/main/lulu3.png?raw=true",
    water:  "https://github.com/z883662/Aruru/blob/main/lulu4.png?raw=true",
    angry:  "https://github.com/z883662/Aruru/blob/main/lulu5.png?raw=true",
  };

  // ====== è¿·å®®è—åœ–ï¼ˆ28x18ï¼‰ ======
  const MAP = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "######.##          ##.######",
    "#..........###G###..........#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "#......##....P.....##......#",
    "############################",
  ];

  // ====== Canvas ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // ====== UI ======
  const elNick   = document.getElementById("nick");
  const elScore  = document.getElementById("score");
  const elLives  = document.getElementById("lives");
  const elRemain = document.getElementById("remain");
  const elState  = document.getElementById("state");

  const overlay = document.getElementById("overlay");
  const modalTitle = document.getElementById("modalTitle");
  const modalText  = document.getElementById("modalText");
  const nameInput  = document.getElementById("nameInput");
  const btnStart   = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");
  const btnSound   = document.getElementById("btnSound");
  const btnHelp    = document.getElementById("btnHelp");

  const helpCard = document.getElementById("helpCard");

  const lbBody = document.getElementById("lbBody");
  const lbHint = document.getElementById("lbHint");

  const loadText = document.getElementById("loadText");
  const loadBar  = document.getElementById("loadBar");

  // D-pad
  const padLeft  = document.getElementById("padLeft");
  const padUp    = document.getElementById("padUp");
  const padRight = document.getElementById("padRight");
  const padDown  = document.getElementById("padDown");

  // ====== éŸ³æ•ˆï¼ˆiOS/LINEï¼šé¦–æ¬¡äº’å‹•è§£é–ï¼‰ ======
  let audioEnabled = true;
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudioUnlocked(){
    if (!audioEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    audioUnlocked = true;
  }
  function beep(freq=520, dur=0.05, type="sine", gain=0.03){
    if (!audioEnabled || !audioUnlocked) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }
  window.addEventListener("pointerdown", ensureAudioUnlocked, {passive:true});

  // ====== æ’è¡Œæ¦œï¼ˆLocalStorageï¼Œå‰6åï¼Œä¿ç•™7å¤©ï¼‰ ======
  const LB_KEY = "lulu_pacman_lb_v2";
  const KEEP_MS = 7 * 24 * 60 * 60 * 1000;

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      const now = Date.now();
      return arr.filter(x => x && typeof x.score==="number" && typeof x.name==="string" && typeof x.ts==="number" && (now - x.ts) <= KEEP_MS);
    }catch(e){ return []; }
  }
  function saveLB(arr){
    try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch(e){}
  }
  function updateLB(name, score){
    const now = Date.now();
    let lb = loadLB();
    lb.push({name, score, ts: now});
    lb.sort((a,b)=> b.score - a.score || b.ts - a.ts);
    lb = lb.slice(0,6);
    saveLB(lb);
    renderLB();
  }
  function fmtDate(ts){
    const d = new Date(ts);
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  function escapeHtml(s){
    return (s+"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function renderLB(){
    const lb = loadLB();
    lbBody.innerHTML = lb.map((r,i)=>(
      `<tr><td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${r.score}</td><td>${fmtDate(r.ts)}</td></tr>`
    )).join("") || `<tr><td colspan="4" style="color:#a8abff">ç›®å‰æ²’æœ‰ç´€éŒ„</td></tr>`;
    lbHint.textContent = lb.length ? "ï¼ˆè‡ªå‹•æ¸…é™¤è¶…é 7 å¤©ï¼‰" : "ï¼ˆä½ æœƒæ˜¯ç¬¬ä¸€åï¼‰";
  }

  // ====== åœ–ç‰‡é è¼‰ï¼ˆå«é€²åº¦/å¤±æ•—å‚™æ´ï¼‰ ======
  const images = {};
  function loadImageWithTimeout(src, timeoutMs = 12000){
    return new Promise((resolve, reject) => {
      const im = new Image();
      im.crossOrigin = "anonymous";

      const timer = setTimeout(() => {
        cleanup();
        reject(new Error("timeout"));
      }, timeoutMs);

      function cleanup(){
        clearTimeout(timer);
        im.onload = null;
        im.onerror = null;
      }

      im.onload = () => { cleanup(); resolve(im); };
      im.onerror = () => { cleanup(); reject(new Error("error")); };
      im.src = src;
    });
  }

  async function preloadAllImages(){
    const entries = [
      ["player", IMG.player],
      ["dad",    IMG.dad],
      ["mom",    IMG.mom],
      ["water",  IMG.water],
      ["angry",  IMG.angry],
    ];

    let done = 0;
    const total = entries.length;

    btnStart.disabled = true;

    loadText.textContent = `è¼‰å…¥åœ–æª”ä¸­â€¦ 0 / ${total}`;
    loadBar.style.width = `0%`;

    for (const [k, src] of entries){
      try{ images[k] = await loadImageWithTimeout(src); }
      catch(e){
        images[k] = null;
        console.warn("Image failed:", k, src, e);
      }
      done++;
      loadText.textContent = `è¼‰å…¥åœ–æª”ä¸­â€¦ ${done} / ${total}`;
      loadBar.style.width = `${Math.round(done/total*100)}%`;
    }

    const okCount = Object.values(images).filter(Boolean).length;
    loadText.textContent = okCount ? "âœ… åœ–æª”è¼‰å…¥å®Œæˆï¼å¯ä»¥é–‹å§‹äº†" : "âš ï¸ åœ–æª”è¼‰å…¥å¤±æ•—ï¼šå°‡ä»¥å‚™æ´åœ–å½¢é¡¯ç¤ºè§’è‰²ï¼ˆä»å¯éŠç©ï¼‰";
    btnStart.disabled = false;
  }

  // ====== éŠæˆ²åƒæ•¸ ======
  const TILE = 30;
  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  canvas.width  = COLS * TILE;
  canvas.height = ROWS * TILE;

  const SPEED_PLAYER = 5.2;
  const SPEED_GHOST  = 4.8;
  const SPEED_FRIGHT = 3.2;

  const POWER_TIME = 7.0;
  const RESPAWN_TIME = 1.6;

  // ====== åœ°åœ–è³‡æ–™ ======
  const grid = [];
  const dots = new Set();
  const powers = new Set();
  let playerStart = {r:0,c:0};
  let ghostHome = {r:0,c:0};

  function key(r,c){ return r + "," + c; }

  function parseMap(){
    grid.length = 0;
    dots.clear(); powers.clear();
    for (let r=0; r<ROWS; r++){
      const row = [];
      const line = MAP[r];
      for (let c=0; c<COLS; c++){
        const ch = line[c] || " ";
        const isWall = (ch === "#");
        row.push(isWall ? 1 : 0);
        if (ch === ".") dots.add(key(r,c));
        if (ch === "o") powers.add(key(r,c));
        if (ch === "P") playerStart = {r,c};
        if (ch === "G") ghostHome = {r,c};
      }
      grid.push(row);
    }
  }

  function isWall(r,c){
    if (c < 0 || c >= COLS) return false; // tunnel
    if (r < 0 || r >= ROWS) return true;
    return grid[r][c] === 1;
  }

  // ====== å¯¦é«” / æ–¹å‘ ======
  const DIRS = {
    up:    {dr:-1, dc: 0},
    down:  {dr: 1, dc: 0},
    left:  {dr: 0, dc:-1},
    right: {dr: 0, dc: 1},
    none:  {dr: 0, dc: 0},
  };
  function opposite(d){
    if (d===DIRS.up) return DIRS.down;
    if (d===DIRS.down) return DIRS.up;
    if (d===DIRS.left) return DIRS.right;
    if (d===DIRS.right) return DIRS.left;
    return DIRS.none;
  }
  function canMove(r,c,dir){
    const nr = r + dir.dr;
    let nc = c + dir.dc;
    if (nc < 0) nc = COLS-1;
    if (nc >= COLS) nc = 0;
    if (nr < 0 || nr >= ROWS) return false;
    return !isWall(nr,nc);
  }
  function atCenter(x){ return Math.abs(x - Math.round(x)) < 0.05; }

  // ====== éŠæˆ²ç‹€æ…‹ ======
  let nickName = "-";
  let score = 0;
  let lives = 3;
  let powerLeft = 0;
  let running = false;
  let lastTime = 0;

  const player = {
    r:0, c:0, dir:DIRS.left, nextDir:DIRS.left,
    speed: SPEED_PLAYER,
  };

  const ghosts = [
    { name:"é¹¿çˆ¸",     imgKey:"dad",   r:0, c:0, dir:DIRS.left,  base:"chaser", respawn:0, patrolIndex:0 },
    { name:"èŠ±åª½",     imgKey:"mom",   r:0, c:0, dir:DIRS.right, base:"ambush", respawn:0, patrolIndex:1 },
    { name:"é˜¿æ°´",     imgKey:"water", r:0, c:0, dir:DIRS.up,    base:"patrol", respawn:0, patrolIndex:2 },
    { name:"ç”Ÿæ°£é¹¿é¹¿", imgKey:"angry", r:0, c:0, dir:DIRS.down,  base:"random", respawn:0, patrolIndex:3 },
  ];
  const patrolCorners = [
    {r:1, c:1},
    {r:1, c:COLS-2},
    {r:ROWS-2, c:1},
    {r:ROWS-2, c:COLS-2},
  ];

  function syncHUD(){
    elNick.textContent = nickName;
    elScore.textContent = score;
    elLives.textContent = lives;
    elRemain.textContent = dots.size + powers.size;

    if (powerLeft > 0){
      elState.textContent = "å¼·åŒ–";
      elState.style.color = "var(--power)";
    } else {
      elState.textContent = "ä¸€èˆ¬";
      elState.style.color = "var(--ok)";
    }
  }

  function resetGame(){
    parseMap();
    score = 0;
    lives = 3;
    powerLeft = 0;

    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    ghosts.forEach((g,i)=>{
      g.r = ghostHome.r;
      g.c = ghostHome.c + (i%2===0 ? -1 : 1);
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
      g.patrolIndex = i % patrolCorners.length;
    });

    running = true;
    lastTime = performance.now();
    syncHUD();
  }

  // ====== AI ======
  function dist2(a,b){
    const dr = a.r - b.r, dc = a.c - b.c;
    return dr*dr + dc*dc;
  }

  function chooseDirToward(entity, target, avoidOpposite=true){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0];
    let bestScore = Infinity;

    for (const d of options){
      if (avoidOpposite && d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s < bestScore){ bestScore = s; best = d; }
    }
    return best;
  }

  function chooseDirAway(entity, target){
    const r = Math.round(entity.r);
    const c = Math.round(entity.c);
    const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
    if (!options.length) return entity.dir;

    let best = options[0];
    let bestScore = -Infinity;

    for (const d of options){
      if (d === opposite(entity.dir) && options.length>1) continue;
      let nr = r + d.dr;
      let nc = c + d.dc;
      if (nc < 0) nc = COLS-1;
      if (nc >= COLS) nc = 0;
      const s = dist2({r:nr,c:nc}, target);
      if (s > bestScore){ bestScore = s; best = d; }
    }
    return best;
  }

  function getGhostTarget(g){
    const pr = Math.round(player.r);
    const pc = Math.round(player.c);

    if (g.base === "chaser"){
      return {r: pr, c: pc};
    }
    if (g.base === "ambush"){
      const pd = player.dir;
      let tr = pr + pd.dr * 4;
      let tc = pc + pd.dc * 4;
      tr = Math.max(1, Math.min(ROWS-2, tr));
      if (tc < 0) tc = COLS-1;
      if (tc >= COLS) tc = 0;
      return {r: tr, c: tc};
    }
    if (g.base === "patrol"){
      const me = {r: Math.round(g.r), c: Math.round(g.c)};
      const playerHere = {r: pr, c: pc};
      if (dist2(me, playerHere) <= 36) return playerHere; // æ¥è¿‘å°±è¿½
      const corner = patrolCorners[g.patrolIndex];
      if (dist2(me, corner) <= 4) g.patrolIndex = (g.patrolIndex + 1) % patrolCorners.length;
      return patrolCorners[g.patrolIndex];
    }
    return {r: pr, c: pc};
  }

  // ====== ç§»å‹• ======
  function stepEntity(ent, dt, speed){
    const move = speed * dt;

    if (atCenter(ent.r) && atCenter(ent.c)){
      const r = Math.round(ent.r);
      const c = Math.round(ent.c);

      if (ent === player){
        if (canMove(r,c,ent.nextDir)) ent.dir = ent.nextDir;
        else if (!canMove(r,c,ent.dir)) ent.dir = DIRS.none;
      } else {
        if (ent.respawn > 0){
          ent.dir = chooseDirToward(ent, ghostHome, true);
        } else if (powerLeft > 0){
          ent.dir = chooseDirAway(ent, {r: Math.round(player.r), c: Math.round(player.c)});
        } else {
          if (ent.base === "random"){
            const options = [DIRS.up, DIRS.left, DIRS.down, DIRS.right].filter(d => canMove(r,c,d));
            const filtered = options.filter(d => d !== opposite(ent.dir));
            const list = (filtered.length ? filtered : options);
            if (list.length) ent.dir = list[Math.floor(Math.random()*list.length)];
          } else {
            const target = getGhostTarget(ent);
            ent.dir = chooseDirToward(ent, target, true);
          }
        }
      }
    }

    let nr = ent.r + ent.dir.dr * move;
    let nc = ent.c + ent.dir.dc * move;

    // tunnel wrap
    if (nc < 0) nc = COLS - 0.01;
    if (nc >= COLS) nc = 0.01;

    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      } else {
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  // ====== åƒé» ======
  function tryEat(){
    const r = Math.round(player.r);
    const c = Math.round(player.c);
    const k = r + "," + c;

    if (dots.has(k)){
      dots.delete(k);
      score += 1;
      beep(620, 0.04, "sine", 0.025);
      syncHUD();
    } else if (powers.has(k)){
      powers.delete(k);
      score += 5;
      powerLeft = POWER_TIME;
      beep(220, 0.08, "square", 0.03);
      syncHUD();
    }
  }

  function collide(a,b){
    return Math.abs(a.r - b.r) < 0.45 && Math.abs(a.c - b.c) < 0.45;
  }

  function onPlayerHit(){
    lives -= 1;
    beep(140, 0.20, "sawtooth", 0.02);
    if (lives <= 0){
      gameOver();
      return;
    }
    player.r = playerStart.r;
    player.c = playerStart.c;
    player.dir = DIRS.left;
    player.nextDir = DIRS.left;

    ghosts.forEach((g,i)=>{
      g.r = ghostHome.r;
      g.c = ghostHome.c + (i%2===0 ? -1 : 1);
      g.dir = (i%2===0 ? DIRS.left : DIRS.right);
      g.respawn = 0;
    });
    powerLeft = 0;
    syncHUD();
  }

  function gameOver(){
    running = false;
    syncHUD();
    updateLB(nickName, score);

    modalTitle.textContent = "éŠæˆ²çµæŸï¼";
    modalText.textContent = `ä½ çš„åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  function win(){
    running = false;
    updateLB(nickName, score);
    modalTitle.textContent = "é€šé—œæˆåŠŸï¼";
    modalText.textContent = `ä½ æŠŠå«©è‘‰éƒ½åƒå…‰å•¦ï¼åˆ†æ•¸ï¼š${score}`;
    overlay.style.display = "flex";
    btnStart.textContent = "å†ç©ä¸€æ¬¡";
  }

  // ====== ç¹ªåœ– ======
  function drawSprite(img, x, y, size, fallbackColor="#ffffff"){
    if (img){
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      return;
    }
    ctx.fillStyle = fallbackColor;
    ctx.beginPath();
    ctx.arc(x, y, size/2, 0, Math.PI*2);
    ctx.fill();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--wall").trim() || "#2f6bff";
    ctx.lineWidth = 4;
    ctx.lineJoin = "round";
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        if (isWall(r,c)){
          const x = c*TILE, y = r*TILE;
          ctx.strokeRect(x+3, y+3, TILE-6, TILE-6);
        }
      }
    }

    // dots
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--dot").trim() || "#ffd3b6";
    dots.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      ctx.beginPath();
      ctx.arc(x,y,3.2,0,Math.PI*2);
      ctx.fill();
    });

    // power
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--power").trim() || "#ffe066";
    powers.forEach(k=>{
      const [r,c] = k.split(",").map(Number);
      const x = c*TILE + TILE/2;
      const y = r*TILE + TILE/2;
      ctx.beginPath();
      ctx.arc(x,y,7.2,0,Math.PI*2);
      ctx.fill();
    });

    // sprites
    drawSprite(images.player, player.c*TILE + TILE/2, player.r*TILE + TILE/2, 26, "#ffe066");

    ghosts.forEach(g=>{
      const colorMap = { dad:"#ff5a7a", mom:"#ff9bd6", water:"#51ffb0", angry:"#ff7f2a" };

      if (g.respawn > 0) ctx.globalAlpha = 0.55;
      drawSprite(images[g.imgKey], g.c*TILE + TILE/2, g.r*TILE + TILE/2, 26, colorMap[g.imgKey] || "#ffffff");

      if (powerLeft > 0 && g.respawn <= 0){
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "#3aa0ff";
        ctx.beginPath();
        ctx.arc(g.c*TILE + TILE/2, g.r*TILE + TILE/2, 14, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    });

    // power timer
    if (powerLeft > 0){
      ctx.fillStyle = "#ffe066";
      ctx.font = "bold 16px system-ui, -apple-system, Segoe UI";
      ctx.textAlign = "left";
      ctx.fillText("å¼·åŒ–ï¼š" + powerLeft.toFixed(1) + "s", 10, 22);
    }
  }

  // ====== loop ======
  function loop(t){
    if (!running){
      draw();
      requestAnimationFrame(loop);
      return;
    }
    const dt = Math.min(0.04, (t - lastTime) / 1000);
    lastTime = t;

    if (powerLeft > 0) powerLeft = Math.max(0, powerLeft - dt);

    stepEntity(player, dt, SPEED_PLAYER);
    tryEat();

    ghosts.forEach(g=>{
      if (g.respawn > 0) g.respawn = Math.max(0, g.respawn - dt);
      const spd = (powerLeft > 0 && g.respawn<=0) ? SPEED_FRIGHT : SPEED_GHOST;
      stepEntity(g, dt, spd);
    });

    for (const g of ghosts){
      if (collide(player,g)){
        if (powerLeft > 0 && g.respawn<=0){
          score += 10;
          beep(820, 0.06, "triangle", 0.03);
          g.respawn = RESPAWN_TIME;
          g.r = ghostHome.r;
          g.c = ghostHome.c;
          g.dir = DIRS.up;
          syncHUD();
        } else if (g.respawn<=0){
          onPlayerHit();
          break;
        }
      }
    }

    if (dots.size + powers.size === 0) win();

    syncHUD();
    draw();
    requestAnimationFrame(loop);
  }

  // ====== æ¡Œæ©Ÿéµç›¤ï¼ˆä¿ç•™ï¼‰ ======
  window.addEventListener("keydown", (e)=>{
    ensureAudioUnlocked();
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") player.nextDir = DIRS.up;
    if (k === "arrowdown" || k === "s") player.nextDir = DIRS.down;
    if (k === "arrowleft" || k === "a") player.nextDir = DIRS.left;
    if (k === "arrowright" || k === "d") player.nextDir = DIRS.right;
  }, {passive:true});

  // ====== æ‰‹æ©Ÿæ–¹å‘éµæ“æ§ ======
  function bindPad(el, dir){
    const set = (ev) => {
      ev.preventDefault();
      ensureAudioUnlocked();
      player.nextDir = dir;
      beep(480, 0.02, "sine", 0.015);
    };
    el.addEventListener("pointerdown", set, {passive:false});
  }
  bindPad(padLeft, DIRS.left);
  bindPad(padUp, DIRS.up);
  bindPad(padRight, DIRS.right);
  bindPad(padDown, DIRS.down);

  // ====== Buttons ======
  btnSound.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    audioEnabled = !audioEnabled;
    btnSound.textContent = audioEnabled ? "ğŸ”Š è²éŸ³ï¼šé–‹" : "ğŸ”‡ è²éŸ³ï¼šé—œ";
    if (audioEnabled) beep(520, 0.05, "sine", 0.02);
  });

  btnRestart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    resetGame();
  });

  btnHelp.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    const showing = (helpCard.style.display === "block");
    helpCard.style.display = showing ? "none" : "block";
  });

  // é»èƒŒæ™¯ä¹Ÿå¯é—œé–‰ç©æ³•
  helpCard.addEventListener("click", (e)=> e.stopPropagation());
  canvas.addEventListener("pointerdown", ()=>{
    if (helpCard.style.display === "block") helpCard.style.display = "none";
  });

  btnStart.addEventListener("click", ()=>{
    ensureAudioUnlocked();
    let name = (nameInput.value || "").trim();
    if (!name) name = "é¹¿ç²‰";
    nickName = name.slice(0,12);
    overlay.style.display = "none";
    btnStart.textContent = "é–‹å§‹éŠæˆ²";
    resetGame();
  });

  // ====== init ======
  async function init(){
    renderLB();
    parseMap();
    syncHUD();

    overlay.style.display = "flex";
    running = false;

    await preloadAllImages();
    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>
