<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>é˜¿é¹¿é¹¿æ–‡å‰µ-é¹¿é¹¿è¿·å®® GOï¼</title>

  <style>
    :root{
      --bg:#fdecef;
      --panel:#ffffff;
      --line:#e6e6e6;
      --text:#222;
      --muted:#666;

      --pill:#f6f6f6;
      --pillText:#222;
      --btn:#111;
      --btnText:#fff;

      /* åœ°åœ–åº•ï¼šæ·ºé»ƒï¼‹æ·ºç´…æ£•ï¼ˆæ–‘é»ï¼‰ */
      --mapBase:#FFF2C9;
      --mapSpot:#E6C2A4;

      /* ç‰†ï¼šé»ƒåº•ï¼‹ç´…æ£•æ–‘ï¼‹é»‘æ£•é‚Šæ¡†ï¼ˆæ˜é¡¯ï¼‰ */
      --wallBase:#FFD46A;
      --wallSpot:#B2562E; /* ç´…æ£• */
      --wallBorder:#2B1A12; /* é»‘æ£•é‚Šæ¡† */

      /* å«©è‘‰è¦æ›´é®®ç¶  */
      --leaf1:#1BFF6B;
      --leaf2:#00B84D;

      /* èƒ½é‡æœ */
      --power1:#FFD100;
      --power2:#FF7A00;

      --blueWeak:#2EA8FF;

      --radius:16px;
      --safeB: env(safe-area-inset-bottom);
      --safeT: env(safe-area-inset-top);
    }

    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC","PingFang TC","Microsoft JhengHei", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: 8px 10px calc(10px + var(--safeB));
      gap:10px;
    }

    /* ===== Top bar (æ¯”ç…§ä½ æˆªåœ–) ===== */
    .topbar{
      padding-top: var(--safeT);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .brandRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .brand{
      font-weight:900;
      font-size:15px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .pillRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      background: var(--pill);
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 12px;
      font-size:13px;
      color:var(--pillText);
      display:flex;
      align-items:center;
      gap:6px;
      min-height:34px;
    }
    .pill b{font-weight:900}
    .pillBtn{
      cursor:pointer;
      user-select:none;
    }
    .pillBtn:active{transform:translateY(1px)}
    .pillDark{
      background: var(--btn);
      color: var(--btnText);
      border:1px solid #000;
    }

    /* ===== Audio panel (æ¯”ç…§ä½ æˆªåœ–) ===== */
    .audioPanel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .audioRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .check{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:14px;
    }
    .check input{ width:18px; height:18px; }
    .vol{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 52%;
      justify-content:flex-end;
      color:var(--muted);
      font-size:13px;
    }
    input[type="range"]{
      width: 180px;
      max-width: 46vw;
    }

    /* ===== Name row (æ¯”ç…§ä½ æˆªåœ–) ===== */
    .nameRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .nameRow input{
      flex:1;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background:#fff;
      font-size:14px;
      outline:none;
    }
    .applyBtn{
      padding:12px 14px;
      border-radius: 14px;
      border:1px solid var(--line);
      background:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .applyBtn:active{transform:translateY(1px)}
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
      padding:0 2px;
    }

    /* ===== Game area ===== */
    .gameWrap{
      flex:1;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas{
      width:100%;
      max-width: 980px;
      height:auto;
      max-height: calc(100vh - 260px - var(--safeT) - var(--safeB));
      border-radius: 18px;
      border:1px solid var(--line);
      background:#000;
      display:block;
      touch-action:none;
      image-rendering: pixelated;
    }

    /* ===== Bottom dpad ===== */
    .dpad{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 56px 56px;
      gap:10px;
      align-items:center;
      justify-items:stretch;
    }
    .padBtn{
      border-radius: 16px;
      border:1px solid var(--line);
      background: #fff;
      font-weight:900;
      font-size:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .padBtn:active{transform:translateY(1px)}
    .padLeft {grid-column:1; grid-row:1;}
    .padUp   {grid-column:2; grid-row:1;}
    .padRight{grid-column:3; grid-row:1;}
    .padDown {grid-column:2; grid-row:2;}

    /* ===== Overlays ===== */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal{
      width:min(92vw, 560px);
      background:#fff;
      border-radius: 18px;
      border:1px solid var(--line);
      padding:14px;
      box-shadow: 0 18px 70px rgba(0,0,0,.35);
    }
    .modalTitle{
      font-weight:900;
      font-size:16px;
      margin:0 0 8px;
    }
    .modalText{
      margin:0 0 10px;
      font-size:13px;
      color:#444;
      line-height:1.45;
    }
    .modalBtns{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:10px;
    }
    .mBtn{
      border-radius: 14px;
      padding:10px 12px;
      font-weight:900;
      border:1px solid var(--line);
      background:#fff;
      cursor:pointer;
    }
    .mBtn.dark{
      background:#111;
      border-color:#111;
      color:#fff;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size:13px;
    }
    th,td{
      border-bottom:1px solid #eee;
      padding:8px 8px;
      text-align:left;
    }
    th{color:#444; background:#fafafa}

    .smallNote{
      font-size:12px;
      color:#666;
      margin-top:8px;
      line-height:1.35;
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- ===== Topbar ===== -->
    <div class="topbar">
      <div class="brandRow">
        <div>
          <div class="brand">é˜¿é¹¿é¹¿æ–‡å‰µ-é£Ÿé£Ÿé¹¿(åƒé¹¿ç²‰)</div>
          <div class="sub">ç©å®¶ï¼š<span id="uiName">Guest</span>ã€€|ã€€å€ç‡ï¼šx1</div>
        </div>
      </div>

      <div class="pillRow">
        <div class="pill"><span>åˆ†æ•¸</span> <b id="uiScore">0</b></div>
        <div class="pill"><span>æœ€é«˜</span> <b id="uiBest">0</b></div>

        <div class="pill pillBtn" id="btnLB">æŸ¥è©¢æ’è¡Œæ¦œ</div>
        <div class="pill pillBtn" id="btnHelp">ç©æ³•</div>
        <div class="pill pillBtn pillDark" id="btnStart">é–‹å§‹</div>
      </div>
    </div>

    <!-- ===== Audio Panel ===== -->
    <div class="audioPanel">
      <div class="audioRow">
        <div class="check">
          <input type="checkbox" id="chkBgm" checked />
          <label for="chkBgm">BGM</label>
        </div>
        <div class="vol">
          <span>éŸ³é‡</span>
          <input type="range" id="bgmVol" min="0" max="100" value="55" />
        </div>
      </div>

      <div class="audioRow">
        <div class="check">
          <input type="checkbox" id="chkSfx" checked />
          <label for="chkSfx">éŸ³æ•ˆ</label>
        </div>
        <div class="vol">
          <span>éŸ³é‡</span>
          <input type="range" id="sfxVol" min="0" max="100" value="65" />
        </div>
      </div>

      <div class="nameRow">
        <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆå¯é¸ï¼‰" />
        <button class="applyBtn" id="btnApply">å¥—ç”¨</button>
      </div>

      <div class="hint">
        æ’è¡Œæ¦œä½¿ç”¨ LocalStorageï¼ˆå…å¾Œç«¯ï¼‰ã€‚<br/>
        LINE/iOS éœ€ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚
      </div>
    </div>

    <!-- ===== Game ===== -->
    <div class="gameWrap">
      <canvas id="game" width="840" height="510"></canvas>
    </div>

    <!-- ===== D-pad ===== -->
    <div class="dpad">
      <div class="padBtn padLeft"  id="padLeft">â†</div>
      <div class="padBtn padUp"    id="padUp">â†‘</div>
      <div class="padBtn padRight" id="padRight">â†’</div>
      <div class="padBtn padDown"  id="padDown">â†“</div>
    </div>
  </div>

  <!-- ===== HELP Overlay (é–‹å±€è‡ªå‹•é¡¯ç¤º + é–‹å•Ÿæœƒæš«åœ) ===== -->
  <div class="overlay" id="helpOverlay">
    <div class="modal">
      <div class="modalTitle">é˜¿é¹¿é¹¿æ–‡å‰µ-é¹¿é¹¿è¿·å®® GOï¼ï½œç©æ³•</div>
      <div class="modalText">
        ğŸ¦Œ <b>æ“ä½œï¼š</b>æ–¹å‘éµç§»å‹•ï¼ˆæ‰‹æ©Ÿé»ä¸‹æ–¹æ–¹å‘éµï¼›æ¡Œæ©Ÿæ–¹å‘éµ/WASDï¼‰ã€‚<br/>
        ğŸƒ <b>å«©è‘‰é»ï¼š</b>åœ°åœ–ä¸Šçš„ <b>å°å«©è‘‰</b>ï¼Œåƒåˆ° <b>+1 åˆ†</b>ã€‚<br/>
        ğŸ <b>èƒ½é‡æœï¼š</b>åœ°åœ–ä¸Šçš„ <b>é‡‘è‰²èƒ½é‡æœ</b>ï¼Œåƒåˆ° <b>+5 åˆ†</b>ï¼Œä¸¦é€²å…¥ <b>å¼·åŒ–æ¨¡å¼ï¼ˆ7 ç§’ï¼‰</b>ã€‚<br/><br/>
        âš¡ <b>å¼·åŒ–æ¨¡å¼ï¼ˆ7 ç§’ï¼‰ï¼š</b><br/>
        ãƒ»ä½ èº«ä¸Šæœƒæœ‰ <b>æ›´æ˜é¡¯çš„é‡‘è‰²å…‰äº®/å…‰ç’°</b>ï¼ˆHUD æœƒé¡¯ç¤ºã€Œå¼·åŒ–ã€ï¼‰ã€‚<br/>
        ãƒ»æ•µäººæœƒå‡ºç¾ <b>è—è‰²å¼±åŒ–å…‰åœˆ</b>ï¼Œä¸” <b>ç§»å‹•é€Ÿåº¦é™ä½</b>ï¼ˆå¯ç›®è¦–ï¼‰ã€‚<br/>
        ãƒ»ç¢°åˆ°å¼±åŒ–æ•µäººå¯ <b>ååƒ +10 åˆ†</b>ã€‚<br/><br/>
        ğŸ’¥ <b>å¤±æ•—ï¼š</b>éå¼·åŒ–æ™‚ç¢°åˆ°æ•µäººï¼š<b>-1 ç”Ÿå‘½</b>ä¸¦é‡ç”Ÿã€‚<br/>
        âœ¨ <b>é‡ç”Ÿç„¡æ•µï¼š</b>æ¯æ¬¡é‡ç”Ÿå¾Œæœ‰ <b>3 ç§’ç„¡æ•µ</b>ï¼ˆä½ èº«ä¸Šæœƒæœ‰ <b>ç‰¹æ®Šå…‰äº®</b>ï¼Œé¿å…å‰›é‡ç”Ÿå°±è¢«ç¢°åˆ°ï¼‰ã€‚<br/><br/>
        ğŸƒ <b>é€Ÿåº¦èªªæ˜ï¼š</b><br/>
        ãƒ»ç©å®¶é€Ÿåº¦ï¼š<b>å›ºå®š</b>ï¼ˆä¸æœƒå› å¼·åŒ–è€ŒåŠ é€Ÿï¼‰ã€‚<br/>
        ãƒ»æ•µäººé€Ÿåº¦ï¼šé–‹å±€ç‚ºç©å®¶çš„ <b>75%</b>ï¼Œæœƒéš¨éŠæˆ²æ™‚é–“é€æ­¥å¢åŠ ï¼Œä½†ä¸Šé™ <b>ä¸è¶…éç©å®¶ 95%</b>ã€‚<br/>
        ãƒ»å¼±åŒ–ï¼ˆå¼·åŒ–æœŸé–“ï¼‰æ•µäººé€Ÿåº¦ï¼šæœƒå†é™ä½ï¼ˆæ›´å¥½ååƒï¼‰ã€‚<br/>
      </div>
      <div class="modalBtns">
        <button class="mBtn" id="helpClose">é—œé–‰</button>
        <button class="mBtn dark" id="helpStart">é–‹å§‹éŠæˆ²</button>
      </div>
    </div>
  </div>

  <!-- ===== Leaderboard Overlay ===== -->
  <div class="overlay" id="lbOverlay">
    <div class="modal">
      <div class="modalTitle">æ’è¡Œæ¦œï¼ˆä¿ç•™ 7 å¤©ï¼Œåƒ…é¡¯ç¤ºå‰ 6 åï¼‰</div>
      <div class="modalText" id="lbHint"></div>
      <div style="max-height:260px; overflow:auto; border:1px solid #eee; border-radius:12px;">
        <table>
          <thead><tr><th>#</th><th>æš±ç¨±</th><th>åˆ†æ•¸</th><th>æ—¥æœŸ</th></tr></thead>
          <tbody id="lbBody"></tbody>
        </table>
      </div>
      <div class="smallNote">æç¤ºï¼šåˆ†æ•¸è¶Šé«˜è¶Šå‰é¢ï¼›è¶…é 7 å¤©çš„ç´€éŒ„æœƒè‡ªå‹•æ¸…é™¤ã€‚</div>
      <div class="modalBtns">
        <button class="mBtn dark" id="lbClose">é—œé–‰</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Assets =====
  const IMG = {
    player: "https://raw.githubusercontent.com/z883662/Aruru/main/lulu1.png",
    dad:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu2.png",
    mom:    "https://raw.githubusercontent.com/z883662/Aruru/main/lulu3.png",
    water:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu4.png",
    angry:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu5.png",
  };

  // Map: '.'=å«©è‘‰é», 'o'=èƒ½é‡æœ, 'P'=ç©å®¶, 'G'=é¬¼å‡ºç”Ÿ
  const MAP = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.#####.##.#####.######",
    "#....#.#####.##.#####.#....#",
    "######.##..####..##.########",
    "#..........##..G..##.......#",
    "#.####.#####.##.#####.####.#",
    "#o..##................##..o#",
    "###.##.##.########.##.##.###",
    "#......##....P.....##......#",
    "############################",
  ];

  // ===== DOM =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const uiName  = document.getElementById("uiName");
  const uiScore = document.getElementById("uiScore");
  const uiBest  = document.getElementById("uiBest");

  const btnStart = document.getElementById("btnStart");
  const btnHelp  = document.getElementById("btnHelp");
  const btnLB    = document.getElementById("btnLB");

  const chkBgm = document.getElementById("chkBgm");
  const chkSfx = document.getElementById("chkSfx");
  const bgmVol = document.getElementById("bgmVol");
  const sfxVol = document.getElementById("sfxVol");

  const nameInput = document.getElementById("nameInput");
  const btnApply  = document.getElementById("btnApply");

  const padLeft  = document.getElementById("padLeft");
  const padUp    = document.getElementById("padUp");
  const padRight = document.getElementById("padRight");
  const padDown  = document.getElementById("padDown");

  const helpOverlay = document.getElementById("helpOverlay");
  const helpClose   = document.getElementById("helpClose");
  const helpStart   = document.getElementById("helpStart");

  const lbOverlay = document.getElementById("lbOverlay");
  const lbClose   = document.getElementById("lbClose");
  const lbBody    = document.getElementById("lbBody");
  const lbHint    = document.getElementById("lbHint");

  // ===== Utils =====
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function escapeHtml(s){ return (s+"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function fmtDate(ts){
    const d = new Date(ts);
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }

  // ===== Leaderboard (Top6 / 7 days) =====
  const LB_KEY = "aruru_maze_lb_v1";
  const KEEP_MS = 7*24*60*60*1000;

  function loadLB(){
    try{
      const raw = localStorage.getItem(LB_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      const now = Date.now();
      return (Array.isArray(arr)?arr:[])
        .filter(x => x && typeof x.name==="string" && typeof x.score==="number" && typeof x.ts==="number" && (now - x.ts) <= KEEP_MS)
        .sort((a,b)=> b.score - a.score || b.ts - a.ts)
        .slice(0,6);
    }catch(e){ return []; }
  }
  function saveLB(arr){ try{ localStorage.setItem(LB_KEY, JSON.stringify(arr)); }catch(e){} }
  function addLB(name, score){
    const now = Date.now();
    let lb = loadLB();
    lb.push({name, score, ts: now});
    lb.sort((a,b)=> b.score - a.score || b.ts - a.ts);
    lb = lb.slice(0,6);
    saveLB(lb);
    renderLB();
    updateBest();
  }
  function renderLB(){
    const lb = loadLB();
    lbHint.textContent = lb.length ? "ç›®å‰æ’è¡Œæ¦œå¦‚ä¸‹ï¼š" : "ç›®å‰æ²’æœ‰ç´€éŒ„ï¼ˆä½ æœƒæ˜¯ç¬¬ä¸€åï¼‰";
    lbBody.innerHTML = lb.map((r,i)=>(
      `<tr><td>${i+1}</td><td>${escapeHtml(r.name)}</td><td>${r.score}</td><td>${fmtDate(r.ts)}</td></tr>`
    )).join("") || `<tr><td colspan="4" style="color:#777">ç›®å‰æ²’æœ‰ç´€éŒ„</td></tr>`;
  }
  function updateBest(){
    const lb = loadLB();
    const best = lb.length ? lb[0].score : 0;
    uiBest.textContent = best;
  }

  // ===== Audio (BGM + SFX) =====
  let audioCtx = null;
  let unlocked = false;

  // BGM nodes
  let bgmOn = true;
  let sfxOn = true;
  let bgmGain = null;
  let bgmOscA = null;
  let bgmOscB = null;

  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    unlocked = true;
  }
  window.addEventListener("pointerdown", ensureAudio, {passive:true});

  function setBgmVolume(){
    const v = (Number(bgmVol.value)||0)/100;
    if (bgmGain) bgmGain.gain.value = v*0.18; // very gentle
  }
  function setSfxVolume(){ /* sfx uses current slider each play */ }

  function startBgm(){
    if (!unlocked) return;
    if (!bgmOn) return;
    if (bgmOscA) return;

    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.0;

    // simple cute pad: two sines
    bgmOscA = audioCtx.createOscillator();
    bgmOscB = audioCtx.createOscillator();
    bgmOscA.type = "sine";
    bgmOscB.type = "triangle";

    // comfy chord-ish
    bgmOscA.frequency.value = 220;   // A3
    bgmOscB.frequency.value = 277.18; // C#4

    bgmOscA.connect(bgmGain);
    bgmOscB.connect(bgmGain);
    bgmGain.connect(audioCtx.destination);

    bgmOscA.start();
    bgmOscB.start();

    setBgmVolume();

    // gentle fade-in
    const t = audioCtx.currentTime;
    bgmGain.gain.cancelScheduledValues(t);
    bgmGain.gain.setValueAtTime(0.0001, t);
    bgmGain.gain.exponentialRampToValueAtTime(Math.max(0.0001, bgmGain.gain.value), t+0.4);
  }
  function stopBgm(){
    if (!bgmOscA) return;
    const t = audioCtx.currentTime;
    try{
      bgmGain.gain.cancelScheduledValues(t);
      bgmGain.gain.setValueAtTime(bgmGain.gain.value, t);
      bgmGain.gain.exponentialRampToValueAtTime(0.0001, t+0.25);
      bgmOscA.stop(t+0.26);
      bgmOscB.stop(t+0.26);
    }catch(e){}
    bgmOscA = bgmOscB = null;
    bgmGain = null;
  }

  function sfxBeep(freq=520, dur=0.05, type="sine"){
    if (!unlocked) return;
    if (!sfxOn) return;
    const v = (Number(sfxVol.value)||0)/100;
    const g0 = 0.03 * v;

    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(Math.max(0.0001, g0), t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }

  chkBgm.addEventListener("change", ()=>{
    bgmOn = chkBgm.checked;
    ensureAudio();
    if (bgmOn) startBgm(); else stopBgm();
  });
  chkSfx.addEventListener("change", ()=>{ sfxOn = chkSfx.checked; });

  bgmVol.addEventListener("input", ()=>{ setBgmVolume(); });
  sfxVol.addEventListener("input", ()=>{ setSfxVolume(); });

  // ===== Images preload =====
  const images = {};
  function loadImage(src, timeoutMs=15000){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      const timer = setTimeout(()=>{ cleanup(); reject(new Error("timeout")); }, timeoutMs);
      function cleanup(){ clearTimeout(timer); im.onload=null; im.onerror=null; }
      im.onload = ()=>{ cleanup(); resolve(im); };
      im.onerror = ()=>{ cleanup(); reject(new Error("error")); };
      im.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
    });
  }
  async function preloadImages(){
    const entries = Object.entries(IMG);
    for (const [k,src] of entries){
      try{ images[k] = await loadImage(src); }
      catch(e){ images[k] = null; }
    }
  }

  // ===== Game constants =====
  const TILE = 30;
  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  canvas.width = COLS*TILE;
  canvas.height = ROWS*TILE;

  const SPEED_PLAYER = 5.2;               // ç©å®¶å›ºå®šé€Ÿåº¦ï¼ˆ100%ï¼‰
  const GHOST_MIN_RATIO = 0.75;           // (7) é–‹å±€æ€ªç‰© 75%
  const GHOST_MAX_RATIO = 0.95;           // (7) ä¸Šé™ 95%
  const GHOST_RAMP_SECS = 110;            // æ™‚é–“è¶Šä¹…è¶Šå¿«ï¼ˆåˆ°é”ä¸Šé™ç´„ 110sï¼‰

  const POWER_TIME = 7.0;                 // å¼·åŒ– 7 ç§’
  const INVINCIBLE_TIME = 3.0;            // (8) é‡ç”Ÿç„¡æ•µ 3 ç§’

  // å¼·åŒ–æœŸé–“ï¼šæ€ªç‰©é¡å¤–é™é€Ÿï¼ˆå¼±åŒ–ï¼‰
  const WEAK_RATIO = 0.72;                // (11) å¼±åŒ–æ™‚æ€ªç‰©æ›´æ…¢ï¼ˆæœƒåœ¨ç©æ³•èªªæ˜æåŠï¼‰

  const RESPAWN_TIME = 1.2;

  // ===== Map parsing =====
  const grid = [];
  const leaves = new Set(); // '.' å«©è‘‰é»
  const powers = new Set(); // 'o' èƒ½é‡æœ
  let playerStart = {r:0,c:0};
  let ghostHome = {r:0,c:0};

  function k(r,c){ return r+","+c; }
  function parseMap(){
    grid.length=0; leaves.clear(); powers.clear();
    for (let r=0;r<ROWS;r++){
      const row=[];
      for (let c=0;c<COLS;c++){
        const ch = MAP[r][c] || "#";
        const isWall = ch==="#";
        row.push(isWall?1:0);
        if (ch===".") leaves.add(k(r,c));
        if (ch==="o") powers.add(k(r,c));
        if (ch==="P") playerStart={r,c};
        if (ch==="G") ghostHome={r,c};
      }
      grid.push(row);
    }
  }
  function isWall(r,c){
    if (c<0 || c>=COLS) return false; // tunnel
    if (r<0 || r>=ROWS) return true;
    return grid[r][c]===1;
  }

  // ===== Entities =====
  const DIRS = {
    up:{dr:-1,dc:0}, down:{dr:1,dc:0}, left:{dr:0,dc:-1}, right:{dr:0,dc:1}, none:{dr:0,dc:0}
  };
  function opposite(d){
    if (d===DIRS.up) return DIRS.down;
    if (d===DIRS.down) return DIRS.up;
    if (d===DIRS.left) return DIRS.right;
    if (d===DIRS.right) return DIRS.left;
    return DIRS.none;
  }
  function canMove(r,c,dir){
    const nr=r+dir.dr;
    let nc=c+dir.dc;
    if (nc<0) nc=COLS-1;
    if (nc>=COLS) nc=0;
    if (nr<0 || nr>=ROWS) return false;
    return !isWall(nr,nc);
  }
  function atCenter(x){ return Math.abs(x - Math.round(x)) < 0.05; }

  let nickName = "Guest";
  let score = 0;
  let lives = 3;

  let running = false;
  let paused = false;          // (5) ç©æ³•é–‹å•Ÿè‡ªå‹•æš«åœ
  let lastT = 0;
  let gameTime = 0;            // ç”¨æ–¼æ€ªç‰©é€Ÿåº¦ ramp

  let powerLeft = 0;
  let invincibleLeft = 0;      // (8) é‡ç”Ÿç„¡æ•µå€’æ•¸

  const player = {r:0,c:0,dir:DIRS.left,nextDir:DIRS.left};

  const ghosts = [
    {imgKey:"dad",   r:0,c:0,dir:DIRS.left,  base:"chaser", respawn:0, patrolIndex:0},
    {imgKey:"mom",   r:0,c:0,dir:DIRS.right, base:"ambush", respawn:0, patrolIndex:1},
    {imgKey:"water", r:0,c:0,dir:DIRS.up,    base:"patrol", respawn:0, patrolIndex:2},
    {imgKey:"angry", r:0,c:0,dir:DIRS.down,  base:"random", respawn:0, patrolIndex:3},
  ];
  const patrolCorners = [
    {r:1,c:1},{r:1,c:COLS-2},{r:ROWS-2,c:1},{r:ROWS-2,c:COLS-2}
  ];

  function findOpenNear(r,c){
    const offs=[[0,0],[0,-1],[0,1],[-1,0],[1,0],[0,-2],[0,2],[-2,0],[2,0]];
    for (const [dr,dc] of offs){
      const rr=r+dr, cc=c+dc;
      if (rr>=0 && rr<ROWS && cc>=0 && cc<COLS && !isWall(rr,cc)) return {r:rr,c:cc};
    }
    return {r,c};
  }

  function resetGame(){
    parseMap();
    score = 0;
    lives = 3;
    powerLeft = 0;
    invincibleLeft = 0;
    gameTime = 0;

    player.r=playerStart.r; player.c=playerStart.c;
    player.dir=DIRS.left; player.nextDir=DIRS.left;

    const home=findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p=findOpenNear(home.r, home.c + (i%2===0?-1:1));
      g.r=p.r; g.c=p.c;
      g.dir=(i%2===0?DIRS.left:DIRS.right);
      g.respawn=0;
      g.patrolIndex=i%patrolCorners.length;
    });

    running = true;
    paused = false;
    lastT = performance.now();
    syncUI();
  }

  // ===== UI sync =====
  function syncUI(){
    uiName.textContent = nickName;
    uiScore.textContent = score;
    // best handled by updateBest()
  }

  btnApply.addEventListener("click", ()=>{
    ensureAudio();
    const v = (nameInput.value||"").trim();
    nickName = v ? v.slice(0,12) : "Guest";
    syncUI();
    sfxBeep(520,0.04,"sine");
  });

  // ===== Overlays behavior =====
  function openHelp(){
    paused = true;
    helpOverlay.style.display = "flex";
  }
  function closeHelp(){
    helpOverlay.style.display = "none";
    // è‹¥éŠæˆ²å·²é–‹å§‹æ‰æ¢å¾©ï¼›é‚„æ²’é–‹å§‹å°±ä¿æŒä¸è·‘
    paused = false;
  }

  btnHelp.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(480,0.03,"sine");
    openHelp();
  });
  helpClose.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(420,0.03,"sine");
    closeHelp();
  });
  helpStart.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(620,0.05,"triangle");
    helpOverlay.style.display = "none";
    paused = false;
    if (!running) {
      startGameFlow();
    }
  });

  function openLB(){
    paused = true;
    renderLB();
    lbOverlay.style.display = "flex";
  }
  function closeLB(){
    lbOverlay.style.display = "none";
    paused = false;
  }
  btnLB.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(520,0.04,"sine");
    openLB();
  });
  lbClose.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(420,0.03,"sine");
    closeLB();
  });

  // ===== Start button =====
  function startGameFlow(){
    ensureAudio();
    if (bgmOn) startBgm();
    resetGame();
    btnStart.textContent = "é‡æ–°é–‹å§‹";
  }

  btnStart.addEventListener("click", ()=>{
    ensureAudio();
    sfxBeep(660,0.05,"triangle");
    // è‹¥é‚„æ²’é–‹å§‹ï¼Œå…ˆé¡¯ç¤ºç©æ³•ï¼ˆéœ€æ±‚ 6ï¼‰
    if (!running){
      openHelp();
      return;
    }
    // å·²é–‹å§‹ï¼šé‡é–‹
    resetGame();
  });

  // ===== Requirement (6): é–‹å±€å‰è‡ªå‹•é¡¯ç¤ºç©æ³•é®ç½© =====
  function showIntro(){
    running = false;
    paused = true;
    helpOverlay.style.display = "flex";
    btnStart.textContent = "é–‹å§‹";
  }

  // ===== AI helpers =====
  function dist2(a,b){ const dr=a.r-b.r, dc=a.c-b.c; return dr*dr+dc*dc; }

  function chooseDirToward(ent, target, avoidOpp=true){
    const r=Math.round(ent.r), c=Math.round(ent.c);
    const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
    if (!opts.length) return ent.dir;
    let best=opts[0], bestS=Infinity;
    for (const d of opts){
      if (avoidOpp && d===opposite(ent.dir) && opts.length>1) continue;
      let nr=r+d.dr, nc=c+d.dc;
      if (nc<0) nc=COLS-1;
      if (nc>=COLS) nc=0;
      const s=dist2({r:nr,c:nc}, target);
      if (s<bestS){bestS=s; best=d;}
    }
    return best;
  }
  function chooseDirAway(ent, target){
    const r=Math.round(ent.r), c=Math.round(ent.c);
    const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
    if (!opts.length) return ent.dir;
    let best=opts[0], bestS=-Infinity;
    for (const d of opts){
      if (d===opposite(ent.dir) && opts.length>1) continue;
      let nr=r+d.dr, nc=c+d.dc;
      if (nc<0) nc=COLS-1;
      if (nc>=COLS) nc=0;
      const s=dist2({r:nr,c:nc}, target);
      if (s>bestS){bestS=s; best=d;}
    }
    return best;
  }
  function getGhostTarget(g){
    const pr=Math.round(player.r), pc=Math.round(player.c);

    if (g.base==="chaser") return {r:pr,c:pc};

    if (g.base==="ambush"){
      const pd=player.dir;
      let tr=pr+pd.dr*4;
      let tc=pc+pd.dc*4;
      tr=clamp(tr,1,ROWS-2);
      if (tc<0) tc=COLS-1;
      if (tc>=COLS) tc=0;
      return {r:tr,c:tc};
    }

    if (g.base==="patrol"){
      const me={r:Math.round(g.r), c:Math.round(g.c)};
      const pHere={r:pr,c:pc};
      if (dist2(me,pHere)<=36) return pHere;
      const corner=patrolCorners[g.patrolIndex];
      if (dist2(me,corner)<=4) g.patrolIndex=(g.patrolIndex+1)%patrolCorners.length;
      return patrolCorners[g.patrolIndex];
    }

    return {r:pr,c:pc};
  }

  // ===== Speed curve (7) =====
  function ghostRatioByTime(){
    // 0s -> 0.75, ramp to 0.95 by ~GHOST_RAMP_SECS
    const t = clamp(gameTime / GHOST_RAMP_SECS, 0, 1);
    return GHOST_MIN_RATIO + (GHOST_MAX_RATIO - GHOST_MIN_RATIO) * t;
  }

  // ===== Movement step =====
  function stepEntity(ent, dt, speed){
    const move = speed * dt;

    if (atCenter(ent.r) && atCenter(ent.c)){
      const r=Math.round(ent.r), c=Math.round(ent.c);

      if (ent===player){
        if (canMove(r,c,player.nextDir)) player.dir = player.nextDir;
        else if (!canMove(r,c,player.dir)) player.dir = DIRS.none;
      }else{
        if (ent.respawn>0){
          ent.dir = chooseDirToward(ent, ghostHome, true);
        }else if (powerLeft>0){
          ent.dir = chooseDirAway(ent, {r:Math.round(player.r), c:Math.round(player.c)});
        }else{
          if (ent.base==="random"){
            const opts=[DIRS.up,DIRS.left,DIRS.down,DIRS.right].filter(d=>canMove(r,c,d));
            const filtered=opts.filter(d=>d!==opposite(ent.dir));
            const list = filtered.length?filtered:opts;
            if (list.length) ent.dir = list[Math.floor(Math.random()*list.length)];
          }else{
            ent.dir = chooseDirToward(ent, getGhostTarget(ent), true);
          }
        }
      }
    }

    let nr = ent.r + ent.dir.dr*move;
    let nc = ent.c + ent.dir.dc*move;

    if (nc<0) nc=COLS-0.01;
    if (nc>=COLS) nc=0.01;

    if (ent.dir !== DIRS.none){
      const tr = Math.round(nr);
      const tc = Math.round(nc);
      if (tr>=0 && tr<ROWS && !isWall(tr,tc)){
        ent.r = nr; ent.c = nc;
      }else{
        ent.r = Math.round(ent.r);
        ent.c = Math.round(ent.c);
      }
    }
  }

  // ===== Eating / collisions =====
  function tryEat(){
    const r=Math.round(player.r), c=Math.round(player.c);
    const kk=k(r,c);

    if (leaves.has(kk)){
      leaves.delete(kk);
      score += 1;
      uiScore.textContent = score;
      sfxBeep(680,0.03,"sine");
    }else if (powers.has(kk)){
      powers.delete(kk);
      score += 5;
      uiScore.textContent = score;
      powerLeft = POWER_TIME;
      sfxBeep(260,0.08,"square");
    }
  }

  function collide(a,b){
    return Math.abs(a.r-b.r)<0.45 && Math.abs(a.c-b.c)<0.45;
  }

  function respawnPlayer(){
    // (8) é‡ç”Ÿï¼š3 ç§’ç„¡æ•µï¼ˆå¯ç›®è¦–ï¼‰
    player.r=playerStart.r;
    player.c=playerStart.c;
    player.dir=DIRS.left;
    player.nextDir=DIRS.left;
    invincibleLeft = INVINCIBLE_TIME;

    const home=findOpenNear(ghostHome.r, ghostHome.c);
    ghosts.forEach((g,i)=>{
      const p=findOpenNear(home.r, home.c + (i%2===0?-1:1));
      g.r=p.r; g.c=p.c;
      g.dir=(i%2===0?DIRS.left:DIRS.right);
      g.respawn=0;
    });
  }

  function onHit(){
    if (invincibleLeft>0) return; // ç„¡æ•µæœŸé–“ä¸æ‰£
    lives -= 1;
    sfxBeep(140,0.18,"sawtooth");
    if (lives<=0){
      endGame(false);
      return;
    }
    powerLeft = 0;
    respawnPlayer();
  }

  function endGame(win){
    running=false;
    paused=false;
    // å­˜æ’è¡Œæ¦œ
    addLB(nickName, score);
    updateBest();

    // é¡¯ç¤ºæ’è¡Œæ¦œç•¶çµç®—
    openLB();
  }

  // ===== Drawing: map background =====
  function drawMapBackground(){
    // base
    ctx.fillStyle = cssVar("--mapBase");
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // spots
    const spot = cssVar("--mapSpot");
    ctx.globalAlpha = 0.22;
    for (let i=0;i<85;i++){
      const x = (i*97)%canvas.width;
      const y = (i*53)%canvas.height;
      const r = 14 + (i*11)%22;
      ctx.fillStyle = spot;
      ctx.beginPath();
      ctx.ellipse(x,y,r*1.1,r*0.8,(i%10)*0.18,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // ===== Drawing: wall (3) =====
  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawWallTile(x,y,size,seed){
    // å¤–æ¡†ï¼šé»‘æ£•æ˜é¡¯
    const border = cssVar("--wallBorder");
    const base   = cssVar("--wallBase");
    const spot   = cssVar("--wallSpot");

    // drop shadowï¼ˆå¹«ç‰†å’Œåœ°åœ–åº•åšå€åˆ†ï¼‰
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#000";
    roundRect(x+3, y+4, size-6, size-6, 7);
    ctx.fill();
    ctx.globalAlpha = 1;

    // main border
    ctx.fillStyle = border;
    roundRect(x+1.5, y+1.5, size-3, size-3, 7);
    ctx.fill();

    // inner yellow
    ctx.fillStyle = base;
    roundRect(x+4, y+4, size-8, size-8, 6);
    ctx.fill();

    // spots (ç´…æ£•æ–‘)
    ctx.globalAlpha = 0.85;
    for (let i=0;i<2;i++){
      const rr = 4 + ((seed+i*7)%4);
      const ox = x + 9 + ((seed*13 + i*9) % (size-18));
      const oy = y + 9 + ((seed*19 + i*11) % (size-18));
      ctx.fillStyle = spot;
      ctx.beginPath();
      ctx.ellipse(ox, oy, rr*1.2, rr*0.8, (seed%10)*0.1, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // inner highlight for ç«‹é«”æ„Ÿ
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.2;
    roundRect(x+6, y+6, size-12, size-12, 5.5);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawWalls(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        if (!isWall(r,c)) continue;
        const seed = (r*131 + c*197)>>>0;
        drawWallTile(c*TILE, r*TILE, TILE, seed);
      }
    }
  }

  // ===== Drawing: leaf dot (4) more vivid =====
  function drawLeaf(x,y){
    const a=cssVar("--leaf1");
    const b=cssVar("--leaf2");

    // glow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = a;
    ctx.beginPath();
    ctx.arc(x,y,7,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // stem
    ctx.strokeStyle = b;
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(x-1,y+4);
    ctx.lineTo(x+2,y+7);
    ctx.stroke();

    // leaves
    ctx.fillStyle = a;
    ctx.beginPath();
    ctx.ellipse(x-2,y,4.6,3.0,-0.65,0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+2,y+1,4.6,3.0,0.65,0,Math.PI*2);
    ctx.fill();

    // highlight
    ctx.globalAlpha = 0.45;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(x-2,y-0.8,1.8,1.0,-0.65,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawLeaves(){
    leaves.forEach(key=>{
      const [r,c]=key.split(",").map(Number);
      drawLeaf(c*TILE+TILE/2, r*TILE+TILE/2);
    });
  }

  // ===== Drawing: power fruit (clear) =====
  function drawPowerFruit(x,y,t){
    const p1=cssVar("--power1");
    const p2=cssVar("--power2");

    const pulse = 0.5 + 0.5*Math.sin(t*6);
    ctx.globalAlpha = 0.25 + 0.2*pulse;
    ctx.fillStyle = p1;
    ctx.beginPath();
    ctx.arc(x,y, 14+2*pulse, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const g = ctx.createRadialGradient(x-3,y-4,2, x,y,11);
    g.addColorStop(0,"#fff6c9");
    g.addColorStop(0.45,p1);
    g.addColorStop(1,p2);

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(x,y,10,11,0,0,Math.PI*2);
    ctx.fill();

    // star sparkle
    ctx.globalAlpha = 0.65;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(x-12,y); ctx.lineTo(x-7,y);
    ctx.moveTo(x+7,y); ctx.lineTo(x+12,y);
    ctx.moveTo(x,y-12); ctx.lineTo(x,y-7);
    ctx.moveTo(x,y+7); ctx.lineTo(x,y+12);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // leaf
    ctx.fillStyle = cssVar("--leaf1");
    ctx.beginPath();
    ctx.ellipse(x+5,y-11,4.2,2.4,-0.5,0,Math.PI*2);
    ctx.fill();
  }

  function drawPowers(t){
    powers.forEach(key=>{
      const [r,c]=key.split(",").map(Number);
      drawPowerFruit(c*TILE+TILE/2, r*TILE+TILE/2, t + r*0.2 + c*0.1);
    });
  }

  function drawSprite(img, x, y, size, fallback="#111"){
    if (img){
      ctx.drawImage(img, x-size/2, y-size/2, size, size);
    }else{
      ctx.fillStyle=fallback;
      ctx.beginPath();
      ctx.arc(x,y,size/2,0,Math.PI*2);
      ctx.fill();
    }
  }

  // ===== Visual effects ê°•í™”/å¼±í™”/ç„¡æ•µ (9)(8) =====
  function drawPlayerAura(x,y,t){
    // å¼·åŒ–é‡‘å…‰
    if (powerLeft>0){
      const pulse=0.5+0.5*Math.sin(t*9);
      ctx.globalAlpha = 0.35 + 0.25*pulse;
      ctx.fillStyle = cssVar("--power1");
      ctx.beginPath();
      ctx.arc(x,y, 18+3*pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // ç„¡æ•µç™½é‡‘å…‰ï¼ˆæ›´åƒã€Œç‰¹æ®Šå…‰äº®ã€ï¼‰
    if (invincibleLeft>0){
      const pulse=0.5+0.5*Math.sin(t*12);
      ctx.globalAlpha = 0.25 + 0.35*pulse;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x,y, 22+4*pulse, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  function drawGhostWeakRing(x,y,t){
    // å¼±åŒ–è—å…‰æ›´æ˜é¡¯
    const pulse=0.5+0.5*Math.sin(t*8);
    ctx.globalAlpha = 0.22 + 0.20*pulse;
    ctx.fillStyle = cssVar("--blueWeak");
    ctx.beginPath();
    ctx.arc(x,y, 18+4*pulse, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = "#bfe8ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x,y, 22+4*pulse, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // ===== Main draw =====
  function draw(t){
    drawMapBackground();
    drawWalls();
    drawLeaves();
    drawPowers(t);

    // player
    const px = player.c*TILE + TILE/2;
    const py = player.r*TILE + TILE/2;
    drawPlayerAura(px,py,t);
    drawSprite(images.player, px, py, 26, "#333");

    // ghosts
    ghosts.forEach(g=>{
      const gx = g.c*TILE + TILE/2;
      const gy = g.r*TILE + TILE/2;

      if (g.respawn>0) ctx.globalAlpha = 0.55;

      // å¼±åŒ–ç‰¹æ•ˆæ›´å¼·ï¼ˆ9ï¼‰
      if (powerLeft>0 && g.respawn<=0){
        drawGhostWeakRing(gx,gy,t+(g.r+g.c)*0.2);
        // è®“é¬¼æœ¬é«”ç•¥åè—ï¼ˆæ›´æ˜é¡¯ï¼‰
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(46,168,255,0.20)";
        ctx.beginPath();
        ctx.arc(gx,gy,14,0,Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      drawSprite(images[g.imgKey], gx, gy, 26, "#111");
      ctx.globalAlpha = 1;
    });

    // HUD hint: å¼·åŒ–ç‹€æ…‹é¡¯ç¤ºï¼ˆæ¯”ç…§ä½ è¦æ±‚çš„ç›®è¦–å¼·ï¼‰
    // é€™è£¡åœ¨ canvas å·¦ä¸Šè§’åŠ ä¸€å€‹å°æ¨™ï¼ˆä¸å¹²æ“¾é ‚éƒ¨ UIï¼‰
    if (powerLeft>0 || invincibleLeft>0){
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(8,8, 210, 28);
      ctx.globalAlpha = 1;
      ctx.font = "bold 14px system-ui, -apple-system, Segoe UI";
      ctx.fillStyle = powerLeft>0 ? cssVar("--power1") : "#fff";
      let text = "";
      if (powerLeft>0) text += `å¼·åŒ– ${powerLeft.toFixed(1)}s `;
      if (invincibleLeft>0) text += `ç„¡æ•µ ${invincibleLeft.toFixed(1)}s`;
      ctx.fillText(text.trim(), 14, 27);
    }
  }

  // ===== Game loop =====
  function loop(now){
    const t = now/1000;

    if (!running){
      draw(t);
      requestAnimationFrame(loop);
      return;
    }

    const dt = Math.min(0.04, (now - lastT)/1000);
    lastT = now;

    // æš«åœï¼šåªç•«ä¸æ›´æ–°ï¼ˆ5ï¼‰
    if (paused){
      draw(t);
      requestAnimationFrame(loop);
      return;
    }

    // time
    gameTime += dt;

    if (powerLeft>0) powerLeft = Math.max(0, powerLeft - dt);
    if (invincibleLeft>0) invincibleLeft = Math.max(0, invincibleLeft - dt);

    // player move
    stepEntity(player, dt, SPEED_PLAYER);
    tryEat();

    // ghost speed ratio by time, capped
    let gRatio = ghostRatioByTime();
    let ghostSpeed = SPEED_PLAYER * gRatio;

    // weak state: ghosts slower (11)
    if (powerLeft>0) ghostSpeed *= WEAK_RATIO;

    // update ghosts
    ghosts.forEach(g=>{
      if (g.respawn>0) g.respawn = Math.max(0, g.respawn - dt);
      stepEntity(g, dt, ghostSpeed);
    });

    // collisions
    for (const g of ghosts){
      if (!collide(player,g)) continue;

      if (powerLeft>0 && g.respawn<=0){
        // eat ghost
        score += 10;
        uiScore.textContent = score;
        sfxBeep(900,0.06,"triangle");
        g.respawn = RESPAWN_TIME;
        const home=findOpenNear(ghostHome.r, ghostHome.c);
        g.r=home.r; g.c=home.c;
        g.dir=DIRS.up;
      }else if (g.respawn<=0){
        onHit();
        break;
      }
    }

    // win
    if (leaves.size + powers.size === 0){
      sfxBeep(760,0.10,"sine");
      endGame(true);
    }

    draw(t);
    requestAnimationFrame(loop);
  }

  // ===== Controls =====
  function bindPad(el, dir){
    el.addEventListener("pointerdown", (e)=>{
      e.preventDefault();
      ensureAudio();
      player.nextDir = dir;
      sfxBeep(520,0.02,"sine");
    }, {passive:false});
  }
  bindPad(padLeft, DIRS.left);
  bindPad(padUp, DIRS.up);
  bindPad(padRight, DIRS.right);
  bindPad(padDown, DIRS.down);

  window.addEventListener("keydown", (e)=>{
    ensureAudio();
    const k = e.key.toLowerCase();
    if (k==="arrowup" || k==="w") player.nextDir=DIRS.up;
    if (k==="arrowdown" || k==="s") player.nextDir=DIRS.down;
    if (k==="arrowleft" || k==="a") player.nextDir=DIRS.left;
    if (k==="arrowright" || k==="d") player.nextDir=DIRS.right;
  }, {passive:true});

  // ===== Init =====
  async function init(){
    parseMap();
    renderLB();
    updateBest();
    syncUI();

    await preloadImages();

    // é è¨­ï¼šé¡¯ç¤ºç©æ³•é®ç½©ï¼ˆ6ï¼‰
    showIntro();

    requestAnimationFrame(loop);
  }
  init();
})();
</script>
</body>
</html>
